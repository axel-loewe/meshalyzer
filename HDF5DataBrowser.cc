// generated by Fast Light User Interface Designer (fluid) version 1.0303

#include "HDF5DataBrowser.h"
#ifdef USE_HDF5
#endif
#define CTR(A,B,C) (A-B)/2,C,(A-B)/2,""

void HDF5DataBrowser::cb_Read_i(Fl_Return_Button*, void*) {
  process_selections();
}
void HDF5DataBrowser::cb_Read(Fl_Return_Button* o, void* v) {
  ((HDF5DataBrowser*)(o->parent()->user_data()))->cb_Read_i(o,v);
}

void HDF5DataBrowser::cb_Close_i(Fl_Return_Button*, void*) {
  hdf5dataWin->~Fl_Widget();
}
void HDF5DataBrowser::cb_Close(Fl_Return_Button* o, void* v) {
  ((HDF5DataBrowser*)(o->parent()->user_data()))->cb_Close_i(o,v);
}

void HDF5DataBrowser::cb_Clear_i(Fl_Return_Button*, void*) {
  nodDatBrows->select(nodDatBrows->value(),0);
vecDatBrows->select(vecDatBrows->value(),0);
auxGridBrows->select(auxGridBrows->value(),0);
dynPtBrows->select(dynPtBrows->value(),0);
}
void HDF5DataBrowser::cb_Clear(Fl_Return_Button* o, void* v) {
  ((HDF5DataBrowser*)(o->parent()->user_data()))->cb_Clear_i(o,v);
}

HDF5DataBrowser::HDF5DataBrowser( const char *fn, TBmeshWin *meshwin ) {
  { hdf5dataWin = new Fl_Double_Window(445, 550);
    hdf5dataWin->user_data((void*)(this));
    { nodDatBrows = new Fl_Browser(10, 25, 420, 100, "Nodal Data");
      nodDatBrows->type(2);
      nodDatBrows->color((Fl_Color)247);
      nodDatBrows->labelfont(1);
      nodDatBrows->align(Fl_Align(FL_ALIGN_TOP));
    } // Fl_Browser* nodDatBrows
    { vecDatBrows = new Fl_Browser(10, 145, 420, 100, "Vectors");
      vecDatBrows->type(2);
      vecDatBrows->color((Fl_Color)215);
      vecDatBrows->labelfont(1);
      vecDatBrows->align(Fl_Align(FL_ALIGN_TOP));
    } // Fl_Browser* vecDatBrows
    { auxGridBrows = new Fl_Browser(10, 275, 420, 100, "Auxiliary Grids");
      auxGridBrows->type(2);
      auxGridBrows->color((Fl_Color)167);
      auxGridBrows->labelfont(1);
      auxGridBrows->align(Fl_Align(FL_ALIGN_TOP));
    } // Fl_Browser* auxGridBrows
    { dynPtBrows = new Fl_Browser(10, 400, 420, 100, "Dynamic Points");
      dynPtBrows->type(2);
      dynPtBrows->color((Fl_Color)175);
      dynPtBrows->labelfont(1);
      dynPtBrows->align(Fl_Align(FL_ALIGN_TOP));
    } // Fl_Browser* dynPtBrows
    { Fl_Return_Button* o = new Fl_Return_Button(10, 510, 125, 30, "Read");
      o->callback((Fl_Callback*)cb_Read);
    } // Fl_Return_Button* o
    { Fl_Return_Button* o = new Fl_Return_Button(300, 510, 125, 30, "Close");
      o->callback((Fl_Callback*)cb_Close);
    } // Fl_Return_Button* o
    { Fl_Return_Button* o = new Fl_Return_Button(155, 510, 125, 30, "Clear");
      o->callback((Fl_Callback*)cb_Clear);
    } // Fl_Return_Button* o
    hdf5dataWin->end();
  } // Fl_Double_Window* hdf5dataWin
  #ifdef USE_HDF5
  if( ch5_open( fn, &hdf_in ) ) {
    fl_alert( "Not a valid HDF5 file: %s", fn );
    return;
  }
  
  file = fn;
  
  hdf5dataWin->label( fn );
  tbmw = meshwin;
  int num_nodes = tbmw->model->pt.num();
  
  for( int i=0; i<ch5s_nodal_grid_count( hdf_in ); i++ ){
    ch5s_nodal_grid info;
    ch5s_nodal_grid_info( hdf_in, i, &info );
    if( info.type==CH5_SCALAR && info.num_nodes==num_nodes && 
            tbmw->compat_tm(info.time_steps) ) {
      char line[100];
      int len = info.label?strlen(info.label):6;
      sprintf( line, "nodal/%d %*s%*s #tm:%d", i, CTR(78,len,info.label),
                                             info.time_steps );
      nodDatBrows->add( line, (void *)(i) );
    }
    ch5s_nodal_free_grid_info( &info );
  }
  
  for( int i=0; i<ch5s_vector_grid_count( hdf_in ); i++ ){
    ch5s_vector_grid info;
    ch5s_vector_grid_info( hdf_in, i, &info );
    if( tbmw->compat_tm(info.time_steps) ) {
      char line[100];
      int len  = info.label?strlen(info.label):6;
      int slen = info.scalar_label?strlen(info.scalar_label):0;
      sprintf( line, "vector/%d %*s%*s %*s%*s #tm:%d", i, CTR(39,len,info.label),
             CTR(39,slen,info.scalar_label?info.scalar_label:""), info.time_steps );
      vecDatBrows->add( line, (void *)(i) );
    }
    ch5s_vector_free_grid_info( &info );
  }
  
  for( int i=0; i<ch5s_aux_grid_count( hdf_in ); i++ ){
    ch5s_aux_grid info;
    ch5s_aux_grid_info( hdf_in, i, &info );
    if( tbmw->compat_tm(info.time_steps) ) {
      char line[100];
      int len  = info.label?strlen(info.label):6;
      sprintf( line, "auxGrid/%d %*s%*s #tm:%d", i, CTR(78,len,info.label),
                                                               info.time_steps );
      auxGridBrows->add( line, (void *)(i) );
    }
    ch5s_aux_free_grid_info( &info );
  }
  
  for( int i=0; i<ch5s_nodal_grid_count( hdf_in ); i++ ){
    ch5s_nodal_grid info;
    ch5s_nodal_grid_info( hdf_in, i, &info );
    if( info.type==CH5_DYN_PTS && info.num_nodes == num_nodes && 
            tbmw->compat_tm(info.time_steps) ) {
      char line[100];
      int len  = info.label?strlen(info.label):6;
      sprintf( line, "nodal/%d %*s%*s #tm:%d",i,CTR(78,len,info.label),info.time_steps);
      dynPtBrows->add( line, (void *)(i) );
    }
    ch5s_nodal_free_grid_info( &info );
  }
  hdf5dataWin->show();
  #endif
}

void HDF5DataBrowser::process_selections() {
  int ln = nodDatBrows->value();
  if( ln ) {
    ostringstream grid;
    grid << file << ":nodal/" << ((long)(nodDatBrows->data(ln)));
    tbmw->get_data( grid.str().c_str(), tbmw->contwin->tmslider );
  }
  
  ln = vecDatBrows->value();
  if( ln ) {
    stringstream grid;
    grid << file << ":vector/" << ((long)(vecDatBrows->data(ln)));
    if(!tbmw->getVecData( tbmw->contwin->tmslider, grid.str().c_str() ))
      tbmw->contwin->vectorgrp->activate();
  }
  
  ln = auxGridBrows->value();
  if( ln ) {
    stringstream grid;
    grid << file << ":auxGrid/" << ((long)(auxGridBrows->data(ln)));
    if(!tbmw->readAuxGrid( tbmw->contwin->tmslider, grid.str().c_str() ))
      tbmw->contwin->auxgridgrp->activate();
  }
  
  ln = dynPtBrows->value();
  if( ln ) {
    stringstream grid;
    grid << file << ":nodal/" << ((long)(dynPtBrows->data(ln)));
    tbmw->read_dynamic_pts( grid.str().c_str(), tbmw->contwin->tmslider );
  }
}
#ifdef USE_HDF5
#endif
