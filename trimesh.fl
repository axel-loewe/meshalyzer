# data file for the Fltk User Interface Designer (fluid)
version 1.0304
header_name {.h}
code_name {.cc}
decl {\#include "Surfaces.h"} {public local
}

decl {\#include <FL/gl.h>} {public local
}

decl {\#include <vector>} {private local
}

decl {class TBmeshWin;} {public local
}

decl {\#include "HDF5DataBrowser.h"} {private local
}

decl {class IsoSurface;} {public local
}

decl {class ObjProps;} {public local
}

decl {\#define SAVE_WIDGET(f,a) f<<\#a<<" = "<<double(a->value())<<endl;} {private local
}

decl {\#define TEST_VAR(A,B,C) if(!strcmp(\#A,B)){A->value(C);A->do_callback();continue;}} {private local
}

decl {\#define TEST_RADIO(A,B,C,D) if(!strcmp(\#A,B)){if(C){A->setonly();A->do_callback(D);}continue;}} {private local
}

decl {\#define TEST_CHOICE(A,B,C) if(!strcmp(\#A,B)){A->value(C);A->mvalue()->do_callback(A);continue;}} {private local
}

decl {\#define TEST_MENUVAR(A,B,C,D) if(!strcmp(\#A,B)){if(C)A->set();else A->clear();if(A->callback())A->do_callback(D);continue;}} {private local
}

decl {\#define IGNORE_VAR(A,B) if(!strcmp(\#A,B)){continue;}} {private local
}

decl {\#define MAX_INIT_VECS 200000} {private local
}

decl {\#include "Model.h"} {public local
}

decl {\#include <set>} {private local
}

decl {\#include "colourchoice.h"} {public local
}

class Meshwin {} {
  Function {Meshwin()} {open
  } {
    Fl_Window winny {
      label meshalyzer
      callback {if( fl_choice("Really quit?","No","Yes",0) )exit(0);} open
      xywh {174 592 455 455} type Double hide resizable hotspot
    } {
      Fl_Box trackballwin {
        callback {if( fl_choice("Really quit?","No","Yes",0 ) ) exit(0);}
        xywh {0 0 455 455}
        code0 {\#include "TBmeshWin.h"}
        class TBmeshWin
      }
    }
    code {winny->resizable(trackballwin);
winny->size_range(50,50,1600,1600,5,5,1);} {}
  }
  class UserInterface {open
  } {}
}

class Controls {open
} {
  decl {friend class ObjProps;} {private local
  }
  Function {Controls()} {open
  } {
    Fl_Window window {
      label {Meshalyzer Controls} open
      xywh {2008 91 350 645} type Double box UP_BOX
      code0 {\#include <FL/Fl_Color_Chooser.H>}
      code1 {\#include "VecData.h"} visible
    } {
      Fl_Menu_Bar mainbar {open
        xywh {0 0 350 30} labelcolor 1
      } {
        Submenu {} {
          label File open
          xywh {0 0 100 20}
        } {
          MenuItem {} {
            label {Add surface}
            callback {char *fn=fl_file_chooser("Surface", "*.{tris,surf,tri}",NULL);
int sn;
if( fn != NULL ) {
  if( (sn=mwtb->add_surface(fn))>0 ) {
    for( int s=0; s<sn; s++ ) {
      surflist->add(mwtb->model->surface(surflist->nitems())->label().c_str(),1);
    }
    elehi->activate();
    elehi->maximum(mwtb->model->number(SurfEle)-1);
    mwtb->redraw();
    surflist->redraw();
  }
}}
            xywh {0 0 100 20}
          }
          MenuItem {} {
            label {Compute surfaces}
            callback {fl_cursor( FL_CURSOR_WAIT ); 
Fl::check();
int nsa=mwtb->model->add_region_surfaces();
int ns = mwtb->model->numSurf();
for( int i=ns-nsa; i<ns; i++ )  
  surflist->add( mwtb->model->surface(i)->label().c_str(),1);
surflist->redraw();
fl_cursor( FL_CURSOR_DEFAULT );
Fl::check();
write_surfaces(ns-nsa);}
            xywh {0 0 30 20} divider
          }
          MenuItem {} {
            label {Read ASCII data}
            callback {char *fn=fl_file_chooser("Data file","*{out,dat}*",NULL);
if(fn != NULL) mwtb->get_data(fn,tmslider);
mincolval->value(mwtb->cs->min());
maxcolval->value(mwtb->cs->max());}
            xywh {0 0 100 20}
            code0 {\#include <FL/Fl_File_Chooser.H>}
          }
          MenuItem {} {
            label {Read IGB data}
            callback {char *fn=fl_file_chooser("Data file","*igb*",NULL);
if(fn != NULL) {
  fl_cursor(FL_CURSOR_WAIT);
  Fl::check();
  mwtb->get_data(fn,tmslider);
  fl_cursor(FL_CURSOR_DEFAULT);
  Fl::check();
}
mincolval->value(mwtb->cs->min());
maxcolval->value(mwtb->cs->max());}
            xywh {20 20 100 20}
            code0 {\#include <FL/Fl_File_Chooser.H>}
          }
          MenuItem {} {
            label {Read Vector Data}
            callback {if( !mwtb->getVecData(tmslider) ) {
  vectorgrp->activate();
  tabwidget->value(vectorgrp);
}}
            xywh {0 0 100 20}
          }
          MenuItem {} {
            label {Read Aux Grid}
            callback {char *fn = fl_file_chooser( "Auxiliary Grid", "*.pts_t", NULL );
if( fn && !mwtb->readAuxGrid(tmslider,fn) ) {
  auxgridgrp->activate();
  tabwidget->value(auxgridgrp);
  float val;
  if( mwtb->auxGrid->highlight_vertex(0,val))
     auxvertval->value(val);
   else
     auxvertval->value(0);
   auxhivert->value(0);
}}
            xywh {0 0 100 20}
          }
          MenuItem {} {
            label {Read Dyn Pts}
            callback {char *fn = fl_file_chooser("Dynamic Points", "*.dynpt", NULL );
if( fn ) mwtb->read_dynamic_pts( fn, tmslider );}
            xywh {0 0 30 20}
          }
          MenuItem hdfreadbut {
            label {Read  HDF5 Data}
            callback {\#ifdef USE_HDF5
HDF5DataBrowser *brow =  new HDF5DataBrowser( fl_file_chooser("Choose HDF5 data file", "*.datH5", NULL ), mwtb );
\#endif}
            xywh {0 0 30 20}
          }
          MenuItem read_recalibrate {
            label {Recalibrate on read}
            tooltip {Recalibrate colour scale when reading a new data file} xywh {0 0 100 20} type Toggle value 1
          }
          MenuItem read_threaded {
            label {Force threaded read}
            callback {mwtb->forceThreadData(o->value());}
            tooltip {do not attempt to read whole data file into memroy} xywh {0 0 100 20} type Toggle divider
          }
          MenuItem {} {
            label {Save transform}
            callback {char*fn;
fn=fl_file_chooser("Save Xfrm","*.xfrm",NULL);
if( fn != NULL )
 mwtb->trackball.save(fn);}
            xywh {0 0 100 20}
          }
          MenuItem {} {
            label {Read transform}
            callback {char *fn = fl_file_chooser("Xfrm file","*.xfrm",NULL);
if( fn != NULL ){
  mwtb->trackball.read(fn);
  mwtb->redraw();
}}
            xywh {0 0 100 20} divider
          }
          MenuItem {} {
            label {Save state}
            callback {save_state();}
            xywh {0 0 100 20}
          }
          MenuItem {} {
            label {Restore state}
            callback {restore_state();}
            xywh {10 10 100 20} divider
          }
          MenuItem {} {
            label Link
            callback {mwtb->tmLink->list_mesh_pids();
mwtb->tmLink->window->show();}
            xywh {0 0 30 20} divider
          }
          MenuItem {} {
            label Quit
            callback {exit(0);}
            xywh {0 0 100 20}
          }
        }
        Submenu imgmenu {
          label Image open
          xywh {0 0 100 20}
        } {
          MenuItem {} {
            label {Reset transform}
            callback {mwtb->trackball.Reset();
float md = mwtb->get_maxdim();
mwtb->trackball.mouse.SetOglPosAndSize(-md, md, 2*md, 2*md );
mwtb->trackball.size = md;
const GLfloat* po=mwtb->model->pt_offset();
mwtb->trackball.SetOrigin(-po[0],-po[1],-po[2]);
mwtb->redraw();}
            xywh {0 0 100 20}
          }
          MenuItem {} {
            label {Raise window}
            callback {mwtb->parent()->show();}
            xywh {0 0 33 23}
          }
          Submenu {} {
            label View
            xywh {0 0 100 20}
          } {
            Submenu {} {
              label {+X}
              xywh {0 0 100 20}
            } {
              MenuItem {} {
                callback {set_rot('X',0,0);}
                image {ppaxis.png} xywh {0 0 100 20}
              }
              MenuItem {} {
                label item
                callback {set_rot('X',0,1);}
                image {npaxis.png} xywh {10 10 100 20}
              }
              MenuItem {} {
                label item
                callback {set_rot('X',0,2);}
                image {nnaxis.png} xywh {20 20 100 20}
              }
              MenuItem {} {
                label item
                callback {set_rot('X',0,3);}
                image {pnaxis.png} xywh {30 30 100 20}
              }
            }
            Submenu {} {
              label {+Y}
              xywh {5 5 100 20}
            } {
              MenuItem {} {
                callback {set_rot('Y',0,0);}
                image {ppaxis.png} xywh {10 10 100 20}
              }
              MenuItem {} {
                label item
                callback {set_rot('Y',0,1);}
                image {npaxis.png} xywh {20 20 100 20}
              }
              MenuItem {} {
                label item
                callback {set_rot('Y',0,2);}
                image {nnaxis.png} xywh {30 30 100 20}
              }
              MenuItem {} {
                label item
                callback {set_rot('Y',0,3);}
                image {pnaxis.png} xywh {40 40 100 20}
              }
            }
            Submenu {} {
              label {+Z}
              xywh {20 20 100 20}
            } {
              MenuItem {} {
                callback {set_rot('Z',0,0);}
                image {ppaxis.png} xywh {20 20 100 20}
              }
              MenuItem {} {
                label item
                callback {set_rot('Z',0,1);}
                image {npaxis.png} xywh {30 30 100 20}
              }
              MenuItem {} {
                label item
                callback {set_rot('Z',0,2);}
                image {nnaxis.png} xywh {40 40 100 20}
              }
              MenuItem {} {
                label item
                callback {set_rot('Z',0,3);}
                image {pnaxis.png} xywh {50 50 100 20}
              }
            }
            Submenu {} {
              label {-X}
              xywh {25 25 100 20}
            } {
              MenuItem {} {
                callback {set_rot('X',1,0);}
                image {ppaxis.png} xywh {10 10 100 20}
              }
              MenuItem {} {
                label item
                callback {set_rot('X',1,1);}
                image {npaxis.png} xywh {20 20 100 20}
              }
              MenuItem {} {
                label item
                callback {set_rot('X',1,2);}
                image {nnaxis.png} xywh {30 30 100 20}
              }
              MenuItem {} {
                label item
                callback {set_rot('X',1,3);}
                image {pnaxis.png} xywh {40 40 100 20}
              }
            }
            Submenu {} {
              label {-Y}
              xywh {35 35 100 20}
            } {
              MenuItem {} {
                callback {set_rot('Y',1,0);}
                image {ppaxis.png} xywh {20 20 100 20}
              }
              MenuItem {} {
                label item
                callback {set_rot('Y',1,1);}
                image {npaxis.png} xywh {30 30 100 20}
              }
              MenuItem {} {
                label item
                callback {set_rot('Y',1,2);}
                image {nnaxis.png} xywh {40 40 100 20}
              }
              MenuItem {} {
                label item
                callback {set_rot('Y',1,3);}
                image {pnaxis.png} xywh {50 50 100 20}
              }
            }
            Submenu {} {
              label {-Z}
              xywh {45 45 100 20}
            } {
              MenuItem {} {
                callback {set_rot('Z',1,0);}
                image {ppaxis.png} xywh {30 30 100 20}
              }
              MenuItem {} {
                label item
                callback {set_rot('Z',1,1);}
                image {npaxis.png} xywh {40 40 100 20}
              }
              MenuItem {} {
                label item
                callback {set_rot('Z',1,2);}
                image {nnaxis.png} xywh {50 50 100 20}
              }
              MenuItem {} {
                label item
                callback {set_rot('Z',1,3);}
                image {pnaxis.png} xywh {60 60 100 20}
              }
            }
          }
          Submenu {} {
            label {Randomly colour}
            xywh {0 0 100 20}
          } {
            MenuItem {} {
              label vertices
              callback {mwtb->randomize_color(Vertex);}
              xywh {15 15 100 20}
            }
            MenuItem {} {
              label cables
              callback {mwtb->randomize_color(Cable);}
              xywh {15 15 100 20}
            }
            MenuItem {} {
              label {surface eles}
              callback {mwtb->randomize_color(SurfEle);}
              xywh {0 0 100 20}
            }
            MenuItem {} {
              label surfaces
              callback {mwtb->randomize_color(Surface);}
              xywh {5 5 100 20}
            }
            MenuItem {} {
              label voxele
              callback {mwtb->randomize_color(VolEle);}
              xywh {0 0 30 20}
            }
          }
          Submenu {} {
            label {Background colour}
            xywh {0 0 100 20}
          } {
            MenuItem {} {
              label White
              callback {mwtb->bgd(1);}
              xywh {0 0 100 20}
            }
            MenuItem {} {
              label Gray
              callback {mwtb->bgd(0.6);}
              xywh {10 10 100 20}
            }
            MenuItem {} {
              label Black
              callback {mwtb->bgd(0);}
              xywh {20 20 100 20}
            }
          }
          MenuItem revdraworder {
            label {Reverse draw order}
            user_data revdraworder
            callback {mwtb->revdraworder(((Fl_Menu_Item*)v)->checked());}
            xywh {0 0 100 20} type Toggle
          }
          MenuItem norot {
            label {No rotation}
            user_data norot
            callback {mwtb->norot(((Fl_Menu_Item*)v)->checked());}
            xywh {0 0 30 20} type Toggle
          }
          Submenu {} {
            label Sync open
            xywh {0 0 70 20}
          } {
            MenuItem {} {
              label Viewport
              callback {mwtb->SendViewportSyncMessage();}
              xywh {5 5 30 20}
            }
            MenuItem {} {
              label {Colour Scale}
              callback {mwtb->SendColourSyncMessage();}
              xywh {5 5 30 20}
            }
            MenuItem {} {
              label Time
              callback {mwtb->SendTimeSyncMessage();}
              xywh {0 0 33 23}
            }
            MenuItem {} {
              label Clipping
              callback {mwtb->SendClipSyncMessage();} selected
              xywh {0 0 33 23} divider
            }
            MenuItem {} {
              label {Reference view}
              callback {mwtb->trackball.qRot=mwtb->model->syncRefRot();
mwtb->redraw();}
              xywh {0 0 33 23}
            }
            MenuItem {} {
              label {Set reference view}
              callback {mwtb->model->syncRefRot(mwtb->trackball.GetRotation());}
              xywh {0 0 33 23}
            }
          }
        }
        Submenu {} {
          label Data
          xywh {0 0 100 20}
        } {
          MenuItem {} {
            label Opacity
            callback {mwtb->dataopac->window->show();}
            tooltip {Set opacity based on data values} xywh {0 0 100 20}
          }
          MenuItem {} {
            label Clipping
            callback {mwtb->cplane->window->show();}
            tooltip {manage clipping planes} xywh {10 10 100 20}
          }
          MenuItem {} {
            label Isosurf
            callback {mwtb->isosurfwin->isowin->show();}
            tooltip {isoline and isosurface display} xywh {0 0 31 20}
          }
          MenuItem {} {
            label {Dead range}
            callback {mwtb->deadData->window->show();}
            tooltip {Ignore ranges of data} xywh {0 0 34 20}
          }
          Submenu brcut {
            label {Branch cut}
            tooltip {Do not interpolate over a branch cut} xywh {0 0 70 20}
          } {
            MenuItem brcutNone {
              label None
              callback {mwtb->branch_cut(0,0,0);}
              xywh {0 0 34 20} type Radio value 1
            }
            MenuItem brcutPM1 {
              label {[-1,1)}
              callback {mwtb->branch_cut(-1,1,0.2);}
              xywh {0 0 34 20} type Radio
            }
            MenuItem brcut01 {
              label {[0,1)}
              callback {mwtb->branch_cut(0,1,0.2);}
              xywh {0 0 34 20} type Radio
            }
            MenuItem brcutPMpi {
              label {[-pi,pi)}
              callback {mwtb->branch_cut(-M_PI,M_PI,.2);}
              xywh {0 0 34 20} type Radio
            }
            MenuItem brcut02pi {
              label {[0,2pi)}
              callback {mwtb->branch_cut(0,2*M_PI,.2);}
              xywh {0 0 34 20} type Radio
            }
          }
        }
        Submenu outmenu {
          label Output
          xywh {0 0 100 20}
        } {
          Submenu {} {
            label PNG open
            xywh {5 5 100 20}
          } {
            MenuItem {} {
              label Image
              callback {char *fn = fl_file_chooser("PNG image", "*.png", "image.png" );
if( fn!=NULL)
mwtb->output_png(fn);}
              xywh {10 10 100 20}
            }
            MenuItem {} {
              label Sequence
              callback {Sequence *s=new Sequence( mwtb );
s->window->show();}
              xywh {20 20 100 20}
              code0 {\#include "Sequence.h"}
            }
            MenuItem transBgd {
              label {Transparent Bgd}
              user_data transBgd
              callback {mwtb->transBgd( transBgd->value() );}
              xywh {0 0 30 20} type Toggle
            }
          }
          MenuItem {} {
            label PDF
            callback {char* fn = fl_file_chooser("PDF file name", "*.pdf", "image.pdf");
if( fn==NULL) return;
mwtb->output_pdf( fn,true );}
            xywh {5 5 100 20}
          }
          MenuItem {} {
            label EPS
            callback {char* fn = fl_file_chooser("EPS file name", "*.eps", "image.eps");
if( fn==NULL) return;
mwtb->output_pdf( fn, false );}
            xywh {5 5 100 20}
          }
          MenuItem {} {
            label {Colour Bar}
            callback {char *fn = fl_file_chooser("colour bar image", "*.png", "colour_bar.png" );
if( fn!=NULL)
mwtb->cs->output_png(fn);}
            tooltip {output the colour bar as an image file} xywh {0 0 34 20}
          }
          MenuItem {} {
            label {Visible vertices}
            callback {mwtb->dump_vertices();}
            tooltip {output the indices of the visible vertices} xywh {0 0 100 20}
          }
          Submenu recordmenu {
            label Record
            tooltip {take an image snapshot each time something changes} xywh {0 0 100 20}
          } {
            MenuItem {} {
              label start
              callback {if( !mwtb->recording ) {
  char* fn=fl_file_chooser( "Pick base name", "*.png", "frame.png" );
  if( fn != NULL ) {
    outmenu->labelcolor(FL_GREEN);
    redrawbut->show();
    mwtb->recording=true;
    mwtb->record_events( fn );
  }
}}
              xywh {0 0 100 20}
            }
            MenuItem {} {
              label stop
              callback {mwtb->recording = false;
outmenu->labelcolor(FL_BLACK);
redrawbut->hide();
mainbar->redraw();}
              xywh {0 0 100 20}
            }
          }
        }
        MenuItem redrawbut {
          label Redraw
          callback {mwtb->redraw();}
          xywh {0 0 100 20} labelcolor 180 hide
        }
        MenuItem {} {
          label item
          xywh {0 0 30 20} labeltype NO_LABEL
        }
        MenuItem {} {
          label item
          xywh {0 0 30 20} labeltype NO_LABEL
        }
        MenuItem {} {
          label About
          callback {proginfo->show();}
          xywh {0 0 30 20}
        }
      }
      Fl_Menu_Button datadest {
        label {Data on:}
        xywh {10 50 170 30} color 26
      } {
        MenuItem vertdisp {
          label Vertices
          user_data vertdisp
          callback {if(((Fl_Menu_Item*)v)->checked()) mwtb->datify(Vertex);
else mwtb->undatify(Vertex);}
          xywh {0 0 30 20} type Toggle
        }
        MenuItem cabledisp {
          label Cables
          user_data cabledisp
          callback {if(((Fl_Menu_Item*)v)->checked()) mwtb->datify(Cable);
else mwtb->undatify(Cable);}
          xywh {0 0 30 20} type Toggle
        }
        MenuItem cnnxdisp {
          label Cnnx
          user_data cnnxdisp
          callback {if(((Fl_Menu_Item*)v)->checked()) mwtb->datify(Cnnx);
else mwtb->undatify(Cnnx);}
          xywh {0 0 30 20} type Toggle
        }
        MenuItem surfedgedisp {
          label {Surface edges}
          user_data surfedgedisp
          callback {if(((Fl_Menu_Item*)v)->checked() ) mwtb->datify(SurfEle);
else mwtb->undatify(SurfEle);}
          xywh {0 0 30 20} type Toggle
        }
        MenuItem surfdisp {
          label {Surface Elements}
          user_data surfdisp
          callback {if(((Fl_Menu_Item*)v)->checked() ) mwtb->datify(Surface);
else mwtb->undatify(Surface);}
          xywh {0 0 30 20} type Toggle value 1
        }
        MenuItem voldisp {
          label {Volume Elements}
          user_data voldisp
          callback {if(((Fl_Menu_Item*)v)->checked() ) mwtb->datify(VolEle);
else mwtb->undatify(VolEle);}
          xywh {0 0 30 20} type Toggle
        }
        MenuItem {} {
          label ALL
          callback {mwtb->datify(All);
vertdisp->check();
cabledisp->check();
cnnxdisp->check();
surfedgedisp->check();
surfdisp->check();
voldisp->check();}
          xywh {0 0 30 20}
        }
        MenuItem {} {
          label NONE
          callback {mwtb->undatify(All);
vertdisp->uncheck();
cabledisp->uncheck();
cnnxdisp->uncheck();
surfedgedisp->uncheck();
surfdisp->uncheck();
voldisp->uncheck();}
          xywh {0 0 30 20}
        }
      }
      Fl_Light_Button draw_axes {
        label Axes
        callback {mwtb->redraw();}
        tooltip {toggle axs display} xywh {10 85 65 25}
      }
      Fl_Button voxeleColor {
        label {Voxele  colour}
        callback {static colourChoice* cc=NULL;
cc=pickcolor(VolEle, "Voxele colour",cc);}
        xywh {80 85 100 25} labelsize 13
      }
      Fl_Group dispAs {
        label {Display as:}
        xywh {190 50 150 60} box ENGRAVED_BOX
      } {
        Fl_Check_Button dispAsSurf {
          label Surfaces
          callback {mwtb->dispmode(asSurface);}
          xywh {195 55 90 25} type Radio down_box DIAMOND_DOWN_BOX value 1
        }
        Fl_Check_Button dispAsVol {
          label {Volume Mesh}
          callback {mwtb->dispmode(asTetMesh);}
          xywh {195 80 140 25} type Radio down_box DIAMOND_DOWN_BOX
        }
      }
      Fl_Group regiondisp {
        label Region
        xywh {10 120 330 145} box ENGRAVED_BOX align 17
      } {
        Fl_Light_Button vertbut {
          label Vertices
          callback {bool *selreg = regselected();
mwtb->showobj(Vertex,selreg,static_cast<bool>(o->value()));
delete[] selreg;}
          xywh {160 141 100 25} when 1
        }
        Fl_Light_Button cabbut {
          label Cables
          callback {bool *selreg = regselected();
mwtb->showobj(Cable,selreg,static_cast<bool>(o->value()));
delete[] selreg;}
          xywh {160 166 100 24}
        }
        Fl_Light_Button cnnxbut {
          label Connections
          callback {bool* selreg=regselected();
mwtb->showobj(Cnnx,selreg,static_cast<bool>(o->value()));
delete[] selreg;}
          xywh {160 190 100 25}
        }
        Fl_Button vertprop {
          label props
          callback {if( !objprops[Vertex] )
  objprops[Vertex] = new ObjProps( mwtb, Vertex );
else {
 objprops[Vertex]->update();
}
objprops[Vertex]->win->show();}
          xywh {260 140 70 25} labelsize 12
        }
        Fl_Button connprop {
          label props
          callback {if( !objprops[Cnnx] )
  objprops[Cnnx] = new ObjProps( mwtb, Cnnx );
else {
 objprops[Cnnx]->update();
} 
objprops[Cnnx]->win->show();}
          xywh {260 190 70 25} labelsize 12
        }
        Fl_Light_Button visbut {
          label visible
          callback {bool *selreg=regselected();
mwtb->visibility(selreg, o->value());
delete[] selreg;}
          xywh {160 215 100 20} value 1
        }
        Fl_Button {} {
          label {select all}
          callback {reglist->check_all();
reglist->do_callback();}
          xywh {160 240 90 20}
        }
        Fl_Check_Browser reglist {
          callback {if( objprops[Vertex] ) objprops[Vertex]->update();
if( objprops[Cnnx] )   objprops[Cnnx]->update();
if( objprops[Cable] )  objprops[Cable]->update();}
          xywh {25 130 120 125} when 1
        }
        Fl_Button {} {
          label invert
          callback {for( int i=0; i<=reglist->nitems(); i++ )
  reglist->checked( i, !reglist->checked(i) );
reglist->do_callback();}
          xywh {250 240 80 20} color 0 labelcolor 49
        }
        Fl_Button cableprop {
          label props
          callback {if( !objprops[Cable] )
  objprops[Cable] = new ObjProps( mwtb, Cable );
else {
 objprops[Cable]->update();
} 
objprops[Cable]->win->show();}
          xywh {260 165 70 25} labelsize 12
        }
      }
      Fl_Tabs tabwidget {open
        xywh {10 270 330 220} align 0
      } {
        Fl_Group hilightgrp {
          label Highlight
          xywh {10 305 330 185} color 11 labelfont 1 labelsize 12 labelcolor 121 align 4
        } {
          Fl_Value_Input tethi {
            label {VolEle:}
            callback {mwtb->highlight(VolEle,int((o->value())));}
            xywh {100 345 85 25} labeltype NO_LABEL step 1
            code0 {\#include "MyValueInput.h"}
            class MyValueInput
          }
          Fl_Value_Input elehi {
            label {:Surf Ele}
            callback {mwtb->highlight(SurfEle,static_cast<int>(o->value()));}
            xywh {190 345 85 25} align 8 step 1
            code0 {\#include "MyValueInput.h"}
            class MyValueInput
          }
          Fl_Value_Input cabhi {
            label {:Cable}
            callback {mwtb->highlight(Cable,static_cast<int>(o->value()));}
            xywh {190 375 85 25} align 8 step 1
            code0 {\#include "MyValueInput.h"}
            class MyValueInput
          }
          Fl_Value_Input verthi {
            label {Vertex:}
            callback {mwtb->highlight(Vertex,int(o->value()));}
            xywh {100 405 85 25} step 1
            code0 {\#include "MyValueInput.h"}
            class MyValueInput
          }
          Fl_Value_Input cnnxhi {
            label {Connection:}
            callback {mwtb->highlight(Cnnx,static_cast<int>(o->value()));}
            xywh {100 375 85 25} step 1
            code0 {\#include "MyValueInput.h"}
            class MyValueInput
          }
          Fl_Light_Button hilighton {
            label on
            callback {mwtb->set_hilight( static_cast<bool>(o->value()) );}
            xywh {100 315 85 25}
          }
          Fl_Choice attachtype {
            label attached open
            tooltip {draw which objects associated with vertex} xywh {190 435 140 25} down_box BORDER_BOX align 2 when 1
          } {
            MenuItem {} {
              label {Filled Surf eles}
              callback {mwtb->assc_obj(SurfEle,true);}
              xywh {0 0 36 20}
            }
            MenuItem {} {
              label {Surf ele outline}
              callback {mwtb->assc_obj(SurfEle);}
              xywh {5 5 100 20}
            }
            MenuItem {} {
              label {Vol eles}
              callback {mwtb->assc_obj(VolEle);}
              xywh {5 5 100 20}
            }
            MenuItem {} {
              label {Filled Vol eles}
              callback {mwtb->assc_obj(VolEle, 1 );}
              xywh {5 5 100 20}
            }
            MenuItem {} {
              label {-}
              callback {mwtb->assc_obj(Nothing);}
              xywh {5 5 100 20}
            }
          }
          Fl_Button {} {
            label {current reg/surf}
            callback {highlight_region();}
            tooltip {set all objects to 1st in currently selected surface} xywh {190 315 85 25} labelsize 10
          }
          Fl_Button {} {
            label {?}
            callback {mwtb->hiliteinfo();}
            tooltip {display info on highlighted objects} xywh {290 315 30 25} box ROUND_UP_BOX color 133
          }
          Fl_Value_Output vertvalout {
            label {:value}
            tooltip {vertex value} xywh {190 405 85 25} color 174 align 8
          }
          Fl_Choice hitettype {
            tooltip {display style} xywh {15 345 85 25} down_box BORDER_BOX textsize 10
          } {
            MenuItem {} {
              label {Vol Ele}
              callback {mwtb->solid_hitet(false);
mwtb->redraw();}
              xywh {5 5 100 20}
            }
            MenuItem {} {
              label {Solid Vol Ele}
              callback {mwtb->solid_hitet(true);
mwtb->redraw();}
              xywh {5 5 100 20}
            }
          }
          Fl_Button pickvert {
            label {Pick Vertex}
            callback {o->color(128);
mwtb->select_vertex();}
            tooltip {select a vertex with mouse} xywh {15 435 80 25} color 131 labelsize 12
          }
          Fl_Button {} {
            label {Time series}
            callback {mwtb->timeplot();}
            xywh {100 435 85 25} color 124
          }
        }
        Fl_Group lightgrp {
          label Lights open
          xywh {10 295 330 185} color 188 labelfont 1 labelsize 10 labelcolor 188 hide
        } {
          Fl_Value_Slider lightx {
            label {X direction}
            callback {mwtb->redraw();}
            tooltip {X component of light direction} xywh {15 330 140 20} type Horizontal selection_color 71 labelsize 12 minimum -1
          }
          Fl_Value_Slider lighty {
            label {Y direction}
            callback {mwtb->redraw();}
            tooltip {Y component of light direction} xywh {15 370 140 20} type Horizontal selection_color 190 labelsize 12 minimum -1
          }
          Fl_Value_Slider lightz {
            label {Z directtion}
            callback {mwtb->redraw();}
            tooltip {z component of light direction} xywh {15 410 140 20} type Horizontal selection_color 244 labelsize 12 minimum -1 value 1
          }
          Fl_Button {} {
            label reset
            callback {lightx->value(0);
lighty->value(0.);
lightz->value(1);
mwtb->redraw();}
            tooltip {reset light direction to default} xywh {165 305 60 20} labelsize 12
          }
          Fl_Light_Button showLightDir {
            label {show direction}
            callback {mwtb->redraw();}
            tooltip {draw an arrow indicating the light direction} xywh {125 450 100 25} labelsize 12
          }
          Fl_Button {} {
            label {zero X}
            callback {lightx->value(0);
mwtb->redraw();}
            tooltip {set x component to 0} xywh {15 305 35 20} labelsize 10
          }
          Fl_Button {} {
            label {zero Y}
            callback {lighty->value(0);
mwtb->redraw();}
            tooltip {set y component to 0} xywh {60 305 35 20} labelsize 10
          }
          Fl_Button {} {
            label {zero Z}
            callback {lightz->value(0);
mwtb->redraw();}
            tooltip {set z component to 0} xywh {105 305 35 20} labelsize 10
          }
          Fl_Light_Button illBut {
            label Illuminate
            callback {mwtb->lights((bool)o->value());}
            tooltip {turn on light} xywh {15 450 100 25} value 1 labelsize 12
          }
          Fl_Value_Slider ambientslide {
            label Amb
            callback {mwtb->redraw();}
            tooltip {ambient lighting component level} xywh {175 330 25 95} selection_color 3 labelsize 12
          }
          Fl_Light_Button facetshadBut {
            label {facet shading}
            callback {mwtb->facetshade( (bool)(o->value()) );}
            tooltip {do not blend colours over surface} xywh {235 450 100 25} labelsize 12
          }
          Fl_Light_Button {} {
            label fixed
            callback {mwtb->headlamp(o->value());}
            tooltip {Fixed light - headlamp mode} xywh {240 305 60 20} value 1 labelsize 12 align 148
          }
          Fl_Value_Slider specularslide {
            label Spec
            callback {mwtb->redraw();}
            tooltip {specular lighting component level} xywh {235 330 25 95} selection_color 6 labelsize 12 value 0.75
          }
          Fl_Value_Slider diffuseslide {
            label Diff
            callback {mwtb->redraw();}
            tooltip {specular lighting component level} xywh {295 330 25 95} selection_color 6 labelsize 12 value 0.6
          }
        }
        Fl_Group surfgrp {
          label Surface open
          xywh {15 310 315 175} color 93 labelfont 1 labelsize 12 labelcolor 90 hide
        } {
          Fl_Light_Button surfvisbut {
            label Visible
            callback {vector<int>lst;
surfselected(lst);
mwtb->surfVis(lst,static_cast<bool>(o->value()));}
            xywh {140 395 55 30} value 1 selection_color 2 labelsize 12
          }
          Fl_Light_Button surfoutlinebut {
            label Outline
            callback {vector<int>lst;
surfselected(lst);
mwtb->surfOutline(lst,static_cast<bool>(o->value()));}
            xywh {140 315 90 30}
          }
          Fl_Light_Button surffillbut {
            label Filled
            callback {vector<int> lst;
surfselected(lst);
mwtb->surfFilled(lst,static_cast<bool>(o->value()));}
            xywh {240 315 90 30} value 1
          }
          Fl_Button {} {
            label {Outline colour}
            callback {static surfColourChoice *cc=NULL;
cc=pick_surf_color( SurfEle, "Outline Colour",cc );}
            xywh {140 355 90 30} labelsize 12
          }
          Fl_Button {} {
            label {Fill colour}
            callback {static surfColourChoice *cc=NULL;
cc=pick_surf_color( Surface, "Surface colour",cc );}
            xywh {240 355 90 30} labelsize 12
          }
          Fl_Check_Browser surflist {
            label {apply to}
            xywh {20 320 110 160} type Multi align 5
          }
          Fl_Group {} {
            label Select
            xywh {140 445 185 35} box ENGRAVED_FRAME labelsize 13
          } {
            Fl_Button {} {
              label all
              callback {surflist->check_all();
update_surfGUI(0);}
              xywh {145 450 55 25}
            }
            Fl_Button {} {
              label invert
              callback {bool done=false;

for( int i=1; i<=surflist->nitems(); i++ ) {
    if( !done && !surflist->checked(i) ) {
      done = true;
      update_surfGUI(i-1);
    }
    surflist->checked(i, !surflist->checked(i));
}}
              xywh {205 450 55 25} color 0 labelfont 1 labelsize 12 labelcolor 49
            }
            Fl_Button {} {
              label shown
              callback {bool done=false;

for( int i=1; i<=surflist->nitems(); i++ ) {
    if( !done && mwtb->model->surface(i-1)->visible() ) {
      done = true;
      update_surfGUI(i-1);
    }
    surflist->checked(i,mwtb->model->surface(i-1)->visible());
}}
              xywh {265 450 55 25} color 4 labelfont 1 labelsize 12 labelcolor 49
            }
          }
          Fl_Menu_Button {} {
            label Delete
            xywh {265 395 65 30} box GTK_UP_BOX color 88 labelsize 12 align 20
          } {
            MenuItem {} {
              label really
              callback {vector<int> lst;
surfselected(lst);
int hsurf;
int lnum = mwtb->model->localElemnum( elehi->value(), hsurf );
for( int i=lst.size()-1; i>=0; i-- ){
  if( lst[i]==hsurf )
    lnum = hsurf = 0;
  if( lst[i]<hsurf )
    hsurf--;
  mwtb->model->surfKill( lst[i] );
}
elehi->value( mwtb->model->globalElemnum(hsurf,lnum) );
elehi->do_callback();
refresh_surflist();
if( !mwtb->model->number(SurfEle) )
  elehi->deactivate();}
              xywh {0 0 30 20}
            }
          }
          Fl_Button {} {
            label Rename
            callback {string oldlabel;
int sel;

for( int i=0; i<surflist->nitems(); i++ )
  if(surflist->checked(i+1)) {
    oldlabel = mwtb->model->surface(i)->label();
    sel = i;
    break;
  }

const char* surfname=fl_input("Enter surface name",oldlabel.c_str());
if( !surfname ) return;

mwtb->model->surface(sel)->label(surfname);
  
refresh_surflist(0);

surflist->set_checked(sel+1);

write_surfaces(0);}
            xywh {200 395 60 30} labelsize 12
          }
        }
        Fl_Group vectorgrp {
          label Vectors
          xywh {15 315 315 175} color 75 labelfont 1 labelsize 12 labelcolor 146 hide deactivate
        } {
          Fl_Light_Button veconbut {
            label Vectors
            callback {mwtb->vecdata->display(o->value());
mwtb->redraw();}
            tooltip {display vectors?} xywh {20 325 75 25} value 1
          }
          Fl_Roller veclength {
            label {Arrow Size}
            callback {mwtb->vecdata->length(o->value());
mwtb->redraw();}
            tooltip {scale all vectors} xywh {100 325 150 25} type Horizontal labelsize 12 labelcolor 7 align 8 maximum 100 step 0.01 value 1
          }
          Fl_Button veccolor {
            label colour
            callback {mwtb->vecdata->colourize();
mwtb->redraw();}
            tooltip {fixed colour} xywh {245 360 75 25}
          }
          Fl_Menu_Button veclengthdeterm {
            label Length
            tooltip {determinant of vector length} xywh {20 360 90 25}
          } {
            MenuItem veclenmag {
              label {Vector mag}
              callback {mwtb->vecdata->length_det(Vector);
mwtb->redraw();}
              xywh {5 5 100 20} type Radio value 1
            }
            MenuItem veclenscalar {
              label Scalar
              callback {mwtb->vecdata->length_det(Scalar);
mwtb->redraw();}
              xywh {5 5 100 20} type Radio
            }
            MenuItem veclenfix {
              label Fixed
              callback {mwtb->vecdata->length_det(FixedVCdata);
mwtb->redraw();}
              xywh {5 5 100 20} type Radio
            }
          }
          Fl_Menu_Button veccoldeterm {
            label Colour
            tooltip {determinant of vector colour} xywh {130 360 90 25}
          } {
            MenuItem veccolmag {
              label {Vector mag}
              callback {mwtb->vecdata->colour_det(Vector);
veccolgroup->activate();
veccolor->deactivate();
veccolmin->value(mwtb->vecdata->cs->min());
veccolmax->value(mwtb->vecdata->cs->max());
mwtb->redraw();}
              xywh {15 15 100 20} type Radio value 1
            }
            MenuItem veccolscalar {
              label Scalar
              callback {mwtb->vecdata->colour_det(Scalar);
veccolgroup->activate();
veccolor->deactivate();
veccolmin->value(mwtb->vecdata->cs->min());
veccolmax->value(mwtb->vecdata->cs->max());
mwtb->redraw();}
              xywh {15 15 100 20} type Radio
            }
            MenuItem veccolfix {
              label Fixed
              callback {mwtb->vecdata->colour_det(FixedVCdata);
veccolgroup->deactivate();
veccolor->activate();
mwtb->redraw();}
              xywh {15 15 100 20} type Radio
            }
          }
          Fl_Value_Input vecstride {
            label stride
            callback {mwtb->vecdata->stride(o->value());
mwtb->redraw();}
            xywh {25 441 35 24} labelcolor 7 align 2 when 8 minimum 1 maximum 100000 step 1 value 1
          }
          Fl_Check_Button vecstoch {
            label Stochastic
            callback {mwtb->vecdata->stoch_stride(o->value());
mwtb->redraw();}
            xywh {120 435 75 25} down_box DOWN_BOX labelcolor 7
          }
          Fl_Check_Button vecheads {
            label Heads
            callback {mwtb->vecdata->heads(o->value());
mwtb->redraw();}
            xywh {120 465 90 15} down_box DOWN_BOX value 1 labelcolor 7
          }
          Fl_Value_Input vecstart {
            label start
            callback {mwtb->vecdata->start(o->value());
mwtb->redraw();}
            xywh {75 442 35 24} labelcolor 7 align 2 maximum 10000 step 1
            code1 {\#include "MyValueInput.h"}
            class MyValueInput
          }
          Fl_Group veccolgroup {
            xywh {20 390 305 100} labelfont 1
          } {
            Fl_Value_Input veccolmin {
              label {min:}
              callback {mwtb->vecdata->cs->calibrate(o->value(),mwtb->vecdata->cs->max());
mwtb->redraw();}
              xywh {245 438 80 22} labelsize 12 labelcolor 7 when 8 textsize 12
            }
            Fl_Value_Input veccolmax {
              label {max:}
              callback {mwtb->vecdata->cs->calibrate(mwtb->vecdata->cs->min(),o->value());
mwtb->redraw();}
              xywh {245 463 80 22} labelsize 12 labelcolor 7 when 8 textsize 12
            }
            Fl_Choice veccstype {
              label {colour scale}
              xywh {215 395 110 30} down_box BORDER_BOX labelsize 10 labelcolor 7 align 2
              code0 {\#include "Colourscale.h"}
              code1 {o->value(1);}
            } {
              MenuItem {} {
                callback {mwtb->vecdata->cs->scale(CS_RAINBOW);
mwtb->redraw();}
                image {rainbow.xpm} xywh {20 20 100 20}
              }
              MenuItem {} {
                callback {mwtb->vecdata->cs->scale(CS_BL_RAINBOW);
mwtb->redraw();}
                image {blrainbow.xpm} xywh {20 20 100 20}
              }
              MenuItem {} {
                callback {mwtb->vecdata->cs->scale(CS_HOT);
mwtb->redraw();}
                image {hot.xpm} xywh {20 20 100 20}
              }
              MenuItem {} {
                callback {mwtb->vecdata->cs->scale(CS_COLD_HOT);
mwtb->redraw();}
                image {coldhot.xpm} xywh {20 20 100 20}
              }
              MenuItem {} {
                callback {mwtb->vecdata->cs->scale(CS_GREY);
mwtb->redraw();}
                image {blwhite.xpm} xywh {20 20 100 20}
              }
              MenuItem {} {
                callback {mwtb->vecdata->cs->scale(CS_CG);
mwtb->redraw();}
                image {cg.xpm} xywh {20 20 100 20}
              }
              MenuItem {} {
                callback {mwtb->vecdata->cs->scale(CS_MATLAB);
mwtb->redraw();}
                image {matlab.xpm} xywh {20 20 100 20}
              }
              MenuItem {} {
                callback {mwtb->vecdata->cs->scale(CS_RGREY);
                  mwtb->redraw();}
                image {blred.xpm} xywh {20 20 100 20}
              }
              MenuItem {} {
                callback {mwtb->vecdata->cs->scale(CS_GGREY);
                  mwtb->redraw();}
                image {blgreen.xpm} xywh {20 20 100 20}
              }
              MenuItem {} {
                callback {mwtb->vecdata->cs->scale(CS_BGREY);
                  mwtb->redraw();}
                image {blblue.xpm} xywh {20 20 100 20}
              }
              MenuItem {} {
                callback {mwtb->vecdata->cs->scale(CS_ACID);
                  mwtb->redraw();}
                image {acid_trip.xpm} xywh {20 20 100 20}
              }
              MenuItem {} {
                callback {mwtb->vecdata->cs->scale(CS_P2G);
                  mwtb->redraw();}
                image {Pink2Green.xpm} xywh {20 20 100 20}
              }
              MenuItem {} {
                callback {mwtb->vecdata->cs->scale(CS_VIRIDIS);
                  mwtb->redraw();}
                image {viridis.xpm} xywh {20 20 100 20}
              }
              MenuItem {} {
                callback {mwtb->vecdata->cs->scale(CS_VIRIDIS_LIGHT);
                  mwtb->redraw();}
                image {viridis_light.xpm} xywh {20 20 100 20}
              }
            }
            Fl_Button {} {
              label optimal
              callback {mwtb->vecdata->optimize_cs();
veccolmin->value(mwtb->vecdata->cs->min());
veccolmax->value(mwtb->vecdata->cs->max());
mwtb->redraw();}
              tooltip {calibrate for current time} xywh {125 395 75 30} box ROUND_UP_BOX labelsize 12
            }
            Fl_Light_Button vecautocal {
              label {auto cs}
              callback {mwtb->vecdata->auto_cs(o->value());}
              tooltip {calibrate every new time} xywh {20 400 80 25}
            }
          }
        }
        Fl_Group auxgridgrp {
          label {Aux Grid}
          xywh {15 305 320 180} box UP_BOX color 60 labelfont 1 labelsize 12 labelcolor 60 align 4 hide deactivate
        } {
          Fl_Light_Button auxgriddispbut {
            label On
            callback {mwtb->auxGrid->display( o->value() );
mwtb->redraw();}
            xywh {25 310 35 20} value 1 labelsize 10
          }
          Fl_Button {} {
            label optimal
            callback {mwtb->auxGrid->optimize_cs(tmslider->value());
auxmincolval->value(mwtb->auxGrid->cs.min());
auxmaxcolval->value(mwtb->auxGrid->cs.max());
mwtb->redraw();}
            tooltip {calibrate for current time} xywh {100 310 45 20} box ROUND_UP_BOX labelsize 10
          }
          Fl_Choice auxcstype {
            label {colour scale}
            xywh {195 345 90 20} down_box BORDER_BOX labelsize 10 align 2
            code0 {\#include "Colourscale.h"}
            code1 {o->value(1);}
          } {
            MenuItem {} {
              callback {mwtb->auxGrid->cs.scale(CS_RAINBOW);
mwtb->redraw();}
              image {rainbow.xpm} xywh {10 10 100 20}
            }
            MenuItem {} {
              callback {mwtb->auxGrid->cs.scale(CS_BL_RAINBOW);
mwtb->redraw();}
              image {blrainbow.xpm} xywh {10 10 100 20}
            }
            MenuItem {} {
              callback {mwtb->auxGrid->cs.scale(CS_HOT);
mwtb->redraw();}
              image {hot.xpm} xywh {10 10 100 20}
            }
            MenuItem {} {
              callback {mwtb->auxGrid->cs.scale(CS_COLD_HOT);
mwtb->redraw();}
              image {coldhot.xpm} xywh {10 10 100 20}
            }
            MenuItem {} {
              callback {mwtb->auxGrid->cs.scale(CS_GREY);
mwtb->redraw();}
              image {blwhite.xpm} xywh {10 10 100 20}
            }
            MenuItem {} {
              callback {mwtb->auxGrid->cs.scale(CS_CG);
mwtb->redraw();}
              image {cg.xpm} xywh {10 10 100 20}
            }
            MenuItem {} {
              callback {mwtb->auxGrid->cs.scale(CS_MATLAB);
mwtb->redraw();}
              image {matlab.xpm} xywh {10 10 100 20}
            }
            MenuItem {} {
              callback {mwtb->auxGrid->cs.scale(CS_RGREY);
                mwtb->redraw();}
              image {blred.xpm} xywh {20 20 100 20}
            }
            MenuItem {} {
              callback {mwtb->auxGrid->cs.scale(CS_GGREY);
                mwtb->redraw();}
              image {blgreen.xpm} xywh {20 20 100 20}
            }
            MenuItem {} {
              callback {mwtb->auxGrid->cs.scale(CS_BGREY);
                mwtb->redraw();}
              image {blblue.xpm} xywh {20 20 100 20}
            }
            MenuItem {} {
              callback {mwtb->auxGrid->cs.scale(CS_ACID);
                mwtb->redraw();}
              image {acid_trip.xpm} xywh {20 20 100 20}
            }
            MenuItem {} {
              callback {mwtb->auxGrid->cs.scale(CS_P2G);
                mwtb->redraw();}
              image {Pink2Green.xpm} xywh {20 20 100 20}
            }
            MenuItem {} {
              callback {mwtb->auxGrid->cs.scale(CS_VIRIDIS);
                mwtb->redraw();}
              image {viridis.xpm} xywh {20 20 100 20}
            }
            MenuItem {} {
              callback {mwtb->auxGrid->cs.scale(CS_VIRIDIS_LIGHT);
                mwtb->redraw();}
              image {viridis_light.xpm} xywh {20 20 100 20}
            }
          }
          Fl_Value_Input auxmincolval {
            label min
            callback {mwtb->auxGrid->cs.calibrate(o->value(),mwtb->auxGrid->cs.max());
mwtb->redraw();}
            xywh {20 345 65 20} labelsize 10 align 2 when 4 textsize 10
          }
          Fl_Value_Input auxmaxcolval {
            label max
            callback {mwtb->auxGrid->cs.calibrate(mwtb->auxGrid->cs.min(),o->value());
mwtb->redraw();}
            xywh {90 345 65 20} labelsize 10 align 2 when 4 textsize 10
          }
          Fl_Value_Input auxnumcolev {
            label levels
            callback {mwtb->auxGrid->cs.size((int)(o->value()));
mwtb->redraw();}
            tooltip {colourmap size} xywh {160 345 30 20} labelsize 10 align 2 when 4 minimum 4 maximum 252 step 1 value 64 textsize 12
          }
          Fl_Light_Button auxautocalibratebut {
            label auto
            callback {mwtb->auxGrid->autocolor(o->value());}
            tooltip {autoscale every timestep} xywh {290 345 40 20} labelsize 10 align 16
          }
          Fl_Group {} {
            label Vertex open
            xywh {65 375 255 30} labelsize 12 align 4
          } {
            Fl_Button auxptcolor {
              label color
              callback {static AuxColourChoice *cc=NULL;

if( !cc )
  cc = new AuxColourChoice(mwtb->auxGrid->color(Vertex),Vertex,mwtb);
cc->window->show();}
              xywh {65 380 55 20}
            }
            Fl_Light_Button auxptdat {
              label data
              callback {mwtb->auxGrid->datify(Vertex,o->value());
mwtb->redraw();}
              xywh {125 380 50 20}
            }
            Fl_Value_Input auxptsize {
              label {size:}
              callback {mwtb->auxGrid->size(Vertex,o->value());
mwtb->redraw();}
              xywh {205 380 55 20} labelsize 12 maximum 1e+06 step 5 value 50
            }
            Fl_Choice auxptstyle {
              xywh {260 380 50 20} down_box BORDER_BOX labelsize 10 align 8
              code0 {o->value(2);}
            } {
              MenuItem {} {
                label Off
                callback {mwtb->auxGrid->showobj(Vertex,false);
mwtb->redraw();}
                xywh {10 10 31 20}
              }
              MenuItem {} {
                label Point
                callback {mwtb->auxGrid->showobj(Vertex,true);
mwtb->auxGrid->threeD(Vertex,false);
mwtb->redraw();}
                xywh {10 10 31 20}
              }
              MenuItem {} {
                label 3D
                callback {mwtb->auxGrid->showobj(Vertex,true);
mwtb->auxGrid->threeD(Vertex,true);
mwtb->redraw();}
                xywh {10 10 31 20}
              }
            }
          }
          Fl_Group {} {
            label Lines open
            xywh {65 405 255 25} labelsize 12 align 4
          } {
            Fl_Button auxlinecolor {
              label color
              callback {static AuxColourChoice *cc=NULL;
if( !cc ) cc =new AuxColourChoice(mwtb->auxGrid->color(Cnnx),Cnnx,mwtb);
cc->window->show();}
              xywh {65 405 55 20}
            }
            Fl_Light_Button auxlinedat {
              label data
              callback {mwtb->auxGrid->datify(Cnnx,o->value());
mwtb->redraw();}
              xywh {125 405 50 20}
            }
            Fl_Value_Input auxlinewidth {
              label {size:}
              callback {mwtb->auxGrid->size(Cnnx,o->value());
mwtb->redraw();}
              xywh {205 405 55 20} labelsize 12 maximum 10000 step 5 value 100
            }
            Fl_Choice auxlinestyle {open
              xywh {260 405 50 20} down_box BORDER_BOX labelsize 12 align 8
              code0 {o->value(2);}
            } {
              MenuItem {} {
                label Off
                callback {mwtb->auxGrid->showobj(Cnnx,false);
mwtb->redraw();}
                xywh {15 15 31 20}
              }
              MenuItem {} {
                label Line
                callback {mwtb->auxGrid->showobj(Cnnx,true);
mwtb->auxGrid->threeD(Cnnx,false);
mwtb->redraw();}
                xywh {15 15 31 20}
              }
              MenuItem {} {
                label 3D
                callback {mwtb->auxGrid->showobj(Cnnx,true);
mwtb->auxGrid->threeD(Cnnx,true);
mwtb->redraw();}
                xywh {15 15 31 20}
              }
            }
          }
          Fl_Group {} {
            label Surface open
            xywh {65 430 265 20} labelsize 12 align 4
          } {
            Fl_Button auxsurfcolor {
              label color
              callback {static AuxColourChoice *cc=NULL;
if(!cc)
cc = new AuxColourChoice(mwtb->auxGrid->color(SurfEle),SurfEle,mwtb);
cc->window->show();}
              xywh {65 430 55 20}
            }
            Fl_Light_Button auxsurfdat {
              label data
              callback {mwtb->auxGrid->datify(Surface,o->value());
mwtb->redraw();}
              xywh {125 430 50 20}
            }
            Fl_Value_Input auxsurfline {
              label {size:}
              callback {mwtb->auxGrid->size(SurfEle,o->value());
mwtb->redraw();}
              xywh {205 430 55 20} labelsize 12 maximum 100000 step 5 value 10
            }
            Fl_Choice auxsurfstyle {open
              xywh {260 430 50 20} down_box BORDER_BOX align 8
              code0 {o->value(2);}
            } {
              MenuItem {} {
                label Off
                callback {mwtb->auxGrid->showobj(SurfEle,false);
mwtb->redraw();}
                xywh {10 10 31 20}
              }
              MenuItem {} {
                label Outline
                callback {mwtb->auxGrid->showobj(SurfEle,true);
mwtb->auxGrid->surfill(false);
mwtb->redraw();}
                xywh {10 10 31 20}
              }
              MenuItem {} {
                label Filled
                callback {mwtb->auxGrid->showobj(SurfEle,true);
mwtb->auxGrid->surfill(true);
mwtb->redraw();}
                xywh {10 10 31 20}
              }
            }
          }
          Fl_Group {} {
            label VoxEle open
            xywh {65 454 245 22} labelsize 12 align 4
          } {
            Fl_Button auxvolcolor {
              label color
              callback {static AuxColourChoice *cc=NULL;
if(!cc)
cc=new AuxColourChoice(mwtb->auxGrid->color(VolEle),VolEle,mwtb);
cc->window->show();}
              xywh {65 455 55 20}
            }
            Fl_Light_Button auxvoldat {
              label data
              callback {mwtb->auxGrid->datify(VolEle,o->value());
mwtb->redraw();}
              xywh {125 455 50 20}
            }
            Fl_Value_Input auxvolline {
              label {size:}
              callback {mwtb->auxGrid->size(VolEle,o->value());
mwtb->redraw();}
              xywh {205 455 55 20} labelsize 12 maximum 10000 step 5 value 10
            }
            Fl_Choice auxvolstyle {open
              xywh {260 455 50 20} down_box BORDER_BOX align 8
              code0 {o->value(1);}
            } {
              MenuItem {} {
                label Off
                callback {mwtb->auxGrid->showobj(VolEle,false);
mwtb->redraw();}
                xywh {15 15 31 20}
              }
              MenuItem {} {
                label Outline
                callback {mwtb->auxGrid->showobj(VolEle,true);
mwtb->auxGrid->volfill(false);
mwtb->redraw();}
                xywh {15 15 31 20}
              }
              MenuItem {} {
                label Filled
                callback {mwtb->auxGrid->showobj(VolEle,true);
mwtb->auxGrid->volfill(true);
mwtb->redraw();}
                xywh {15 15 31 20}
              }
            }
          }
          Fl_Button plotAuxTS {
            label Plot
            callback {mwtb->auxGrid->plot(tmslider->value());}
            tooltip {show time series for highlighted point} xywh {305 310 25 20} labelsize 10 deactivate
          }
          Fl_Light_Button hiAuxVert {
            label Hi
            callback {mwtb->auxGrid->highlight(o->value());
if( o->value() ) {
  auxhivert->activate();
  if( mwtb->auxGrid->data() ) {
   auxvertval->activate();
   if( mwtb->auxGrid->plottable() )
     plotAuxTS->activate();
  }  
  float val;
  if(mwtb->auxGrid->highlight_vertex(auxhivert->value(),val) )
    auxvertval->value(val);
} else {
  auxhivert->deactivate();
  auxvertval->deactivate();
  plotAuxTS->deactivate();
}
mwtb->redraw();}
            tooltip {turn on highlighting} xywh {270 310 30 20} labelsize 10
          }
          Fl_Value_Input auxhivert {
            label Hilight
            callback {float val;
if( mwtb->auxGrid->highlight_vertex(o->value(),val) )
  auxvertval->value(val);
mwtb->redraw();}
            tooltip {vertex to highlight and display time series if present} xywh {145 310 45 19} labelsize 10 align 2 step 1 textsize 10 deactivate
            code0 {\#include "MyValueInput.h"}
            class MyValueInput
          }
          Fl_Value_Output auxvertval {
            label {hi value:}
            tooltip {value of highlighted vertex} xywh {195 311 70 18} color 17 selection_color 0 labelsize 10 align 2 textsize 10
          }
          Fl_Light_Button {} {
            label Clip
            callback {mwtb->auxGrid->clip(o->value());
mwtb->redraw();}
            xywh {65 310 35 20} box THIN_UP_BOX labelsize 10
          }
        }
      }
      Fl_Group colorscalegrp {
        xywh {10 490 330 60} box ENGRAVED_BOX
      } {
        Fl_Button {} {
          label optimal
          callback {mwtb->optimize_cs();
mincolval->value(mwtb->cs->min());
maxcolval->value(mwtb->cs->max());}
          tooltip {calibrate for current time} xywh {15 495 45 20} box ROUND_UP_BOX labelsize 10
        }
        Fl_Choice cstype {
          label {colour scale}
          xywh {230 500 105 25} down_box BORDER_BOX labelsize 10 align 2
          code0 {\#include "Colourscale.h"}
          code1 {o->value(1);}
        } {
          MenuItem {} {
            callback {mwtb->cs->scale(CS_RAINBOW);
mwtb->redraw();}
            image {rainbow.xpm} xywh {0 0 100 20}
          }
          MenuItem {} {
            callback {mwtb->cs->scale(CS_BL_RAINBOW);
mwtb->redraw();}
            image {blrainbow.xpm} xywh {0 0 100 20}
          }
          MenuItem {} {
            callback {mwtb->cs->scale(CS_HOT);
mwtb->redraw();}
            image {hot.xpm} xywh {0 0 100 20}
          }
          MenuItem {} {
            callback {mwtb->cs->scale(CS_COLD_HOT);
mwtb->redraw();}
            image {coldhot.xpm} xywh {0 0 100 20}
          }
          MenuItem {} {
            callback {mwtb->cs->scale(CS_GREY);
mwtb->redraw();}
            image {blwhite.xpm} xywh {0 0 100 20}
          }
          MenuItem {} {
            callback {mwtb->cs->scale(CS_CG);
mwtb->redraw();}
            image {cg.xpm} xywh {0 0 100 20}
          }
          MenuItem {} {
            callback {mwtb->cs->scale(CS_MATLAB);
mwtb->redraw();}
            image {matlab.xpm} xywh {0 0 100 20}
          }
          MenuItem {} {
            callback {mwtb->cs->scale(CS_RGREY);
              mwtb->redraw();}
            image {blred.xpm} xywh {20 20 100 20}
          }
          MenuItem {} {
            callback {mwtb->cs->scale(CS_GGREY);
              mwtb->redraw();}
            image {blgreen.xpm} xywh {20 20 100 20}
          }
          MenuItem {} {
            callback {mwtb->cs->scale(CS_BGREY);
              mwtb->redraw();}
            image {blblue.xpm} xywh {20 20 100 20}
          }
          MenuItem {} {
            callback {mwtb->cs->scale(CS_ACID);
              mwtb->redraw();}
            image {acid_trip.xpm} xywh {20 20 100 20}
          }
          MenuItem {} {
            callback {mwtb->cs->scale(CS_P2G);
              mwtb->redraw();}
            image {Pink2Green.xpm} xywh {20 20 100 20}
          }
          MenuItem {} {
            callback {mwtb->cs->scale(CS_VIRIDIS);
              mwtb->redraw();}
            image {viridis.xpm} xywh {20 20 100 20}
          }
          MenuItem {} {
            callback {mwtb->cs->scale(CS_VIRIDIS_LIGHT);
              mwtb->redraw();}
            image {viridis_light.xpm} xywh {20 20 100 20}
          }
        }
        Fl_Value_Input mincolval {
          label min
          callback {mwtb->cs->calibrate(o->value(),mwtb->cs->max());
mwtb->redraw();}
          xywh {65 500 65 25} labelsize 10 align 2 when 4 textsize 12
        }
        Fl_Value_Input maxcolval {
          label max
          callback {mwtb->cs->calibrate(mwtb->cs->min(),o->value());
mwtb->redraw();}
          xywh {130 500 65 25} labelsize 10 align 2 when 4 textsize 12
        }
        Fl_Value_Input numcolev {
          label levels
          callback {mwtb->cs->size((int)(o->value()));
mwtb->redraw();}
          tooltip {colourmap size} xywh {195 500 30 25} labelsize 10 align 2 when 4 minimum 4 maximum 252 step 1 value 64 textsize 12
        }
        Fl_Light_Button autocalibratebut {
          label auto
          callback {mwtb->autocolour(o->value());}
          tooltip {autoscale every timestep} xywh {15 520 45 15} labelsize 10 align 16
        }
        Fl_Button {} {
          callback {mwtb->SendColourSyncMessage();}
          image {sync-icon.png} xywh {315 525 20 20}
        }
      }
      Fl_Group animate_group {
        xywh {10 555 330 85} box ENGRAVED_BOX
      } {
        Fl_Box tmslider {
          label time
          callback {mwtb->set_time(int(o->value()));}
          tooltip {time displayed} xywh {15 570 220 25} box UP_BOX align 1
          code0 {\#include "Myslider.h"}
          class Myslider
        }
        Fl_Button {} {
          label {@>>}
          callback {mwtb->animate_skip( int(frameskip->value()),this );}
          tooltip {start animation} xywh {245 560 25 35} labelcolor 71
        }
        Fl_Button {} {
          label {@||}
          callback {mwtb->animate_skip(0,this);}
          tooltip {stop animation} xywh {275 560 25 35} labelcolor 1
        }
        Fl_Counter frameskip {
          label {\#frames}
          callback {mwtb->animate_skip(int(frameskip->value()),NULL);}
          tooltip {\#frames to  increment} xywh {75 605 130 20} align 4 step 1 value 1
        }
        Fl_Value_Input animdelay {
          label {delay:}
          callback {mwtb->animate_delay(o->value()/1000.);}
          tooltip {delay between frames (ms )} xywh {260 606 70 20} maximum 2000 step 5 value 10
        }
        Fl_Button tsync_but {
          callback {mwtb->SendTimeSyncMessage();}
          image {sync-icon.png} xywh {305 560 25 35} resizable
        }
      }
    }
    code {\#ifdef USE_HDF5
hdfreadbut->activate();
\#else
hdfreadbut->deactivate();
\#endif
memset( objprops, 0, sizeof(ObjProps*)*maxobject );} {}
  }
  Function {outputwin( TBmeshWin *w )} {return_type void
  } {
    code {mwtb = w;} {}
  }
  decl {TBmeshWin *mwtb;} {private local
  }
  decl {Fl_Window* proginfo;} {public local
  }
  decl {ObjProps *objprops[maxobject];} {private local
  }
  Function {pickcolor(Object_t obj, const char* wintitle, colourChoice *cc=NULL )} {open return_type {colourChoice *}
  } {
    code {if( !reglist->nchecked() ) return cc;

GLfloat *col;

for( int mi=0; mi<reglist->nitems(); mi++ ) 
 if( reglist->checked(mi+1) ){
     col = mwtb->get_color(VolEle, mi);
 }

if (!cc ) {
     cc = new colourChoice( col, reglist, obj, mwtb );
     cc->window->label(wintitle);
} else
    cc->window->show();

return cc;} {}
  }
  Function {update_surfGUI( int s )} {return_type void
  } {
    code {if( !mwtb->model->numSurf() ) return;
surfvisbut->value( mwtb->model->surface(s)->visible() );
surfoutlinebut->value( mwtb->model->surface(s)->outline() );
surffillbut->value( mwtb->model->surface(s)->filled() );} {}
  }
  Function {update_regionGUI( int r )} {return_type void
  } {
    code {visbut->value( mwtb->visibility(r) );
vertbut->value( mwtb->showobj(Vertex, r) );
cabbut->value( mwtb->showobj(Cable, r) );
cnnxbut->value( mwtb->showobj(Cnnx, r) );} {}
  }
  Function {highlight_region()} {} {
    code {int regnum;
for( regnum=0; regnum<reglist->nitems(); regnum++ )
  if( reglist->checked(regnum) )
    break;
regnum--;

int objnum = mwtb->reg_first( regnum, VolEle );
mwtb->highlight( VolEle, objnum );
tethi->value( objnum );
objnum = mwtb->reg_first(regnum, Cnnx );
mwtb->highlight( Cnnx, objnum );
cnnxhi->value( objnum );
objnum = mwtb->reg_first( regnum, Cable );
mwtb->highlight( Cable, objnum );
cabhi->value( objnum );
objnum =0;
for( int i=0; i<regnum; i++ ) objnum += mwtb->model->surface(i)->num();
mwtb->highlight( SurfEle, objnum );
elehi->value( objnum );
objnum = mwtb->reg_first( regnum, Vertex );
mwtb->highlight( Vertex, objnum );
verthi->value( objnum );} {}
  }
  Function {set_rot( char n, int neg, int view )} {return_type void
  } {
    code {V3f xaxis(1,0,0);
V3f yaxis(0,1,0);
V3f zaxis(0,0,1);

if( n == 'X' ) {
  mwtb->trackball.SetRotation(-M_PI_2*(1-2*neg),yaxis);
  if( !neg )mwtb->trackball.Rotation(-M_PI_2,zaxis);
} else if( n == 'Y' ) { 
  mwtb->trackball.SetRotation(M_PI_2*(1-2*neg),xaxis);
  if( !neg )mwtb->trackball.Rotation(M_PI_2,zaxis);
} else {
  mwtb->trackball.SetRotation(M_PI*neg,yaxis);
  if( neg )mwtb->trackball.Rotation(-M_PI_2,zaxis);
}
mwtb->trackball.Rotation(-view*M_PI_2,zaxis);

mwtb->redraw();} {}
  }
  Function {set_tet_region( Model *model)} {} {
    code {for( int i=0; i<model->_numReg; i++ ) {
  char text[256];
  sprintf( text, "%d", (model->region(i))->label() );
  reglist->add( text, 0 );
  reglist->checked(i+1,1);
}} {}
  }
  Function {regselected()} {return_type {bool *}
  } {
    code {bool *sel = new bool[reglist->nitems()];
for( int i=1; i<=reglist->nitems(); i++ )
  sel[i-1] = reglist->checked(i);
return sel;} {}
  }
  Function {save_state()} {open
  } {
    code {char *fn = fl_file_chooser("meshalyzer state file","*.mshz",NULL);
if( fn==NULL) return;
string xfn( fn );
if( xfn.rfind(".mshz") == string::npos ) xfn += ".mshz";
ofstream mshzf( xfn.c_str() );

mshzf << "TRACKBALL ======" << endl;
mwtb->trackball.save(mshzf);
mshzf << "CLIPPING ======" << endl;
mwtb->cplane->save(mshzf);
mshzf << "DATA_OPACITY ======" << endl;
mwtb->dataopac->save(mshzf);

SAVE_WIDGET(mshzf,read_recalibrate);
SAVE_WIDGET(mshzf,revdraworder);
SAVE_WIDGET(mshzf,norot);
SAVE_WIDGET(mshzf,transBgd);
SAVE_WIDGET(mshzf,brcutNone);
SAVE_WIDGET(mshzf,brcutPM1);
SAVE_WIDGET(mshzf,brcut01);
SAVE_WIDGET(mshzf,brcutPMpi);
SAVE_WIDGET(mshzf,brcut02pi);
SAVE_WIDGET(mshzf,vertdisp);
SAVE_WIDGET(mshzf,cabledisp);
SAVE_WIDGET(mshzf,cnnxdisp);
SAVE_WIDGET(mshzf,surfedgedisp);
SAVE_WIDGET(mshzf,surfdisp);
SAVE_WIDGET(mshzf,voldisp);
SAVE_WIDGET(mshzf,draw_axes);
SAVE_WIDGET(mshzf,dispAsSurf);
SAVE_WIDGET(mshzf,dispAsVol);
//region group
SAVE_WIDGET(mshzf,vertbut);
SAVE_WIDGET(mshzf,cabbut);
SAVE_WIDGET(mshzf,cnnxbut);
//hilighttab
if( mwtb->timeplotter->graph->n() >= 2 ) {
  mshzf << "HELD_CURVES = ";
  for(int i=2; i<mwtb->timeplotter->graph->n(); i++ ) 
    mshzf << mwtb->timeplotter->graph->id(i) << " ";
  mshzf << endl;
}
SAVE_WIDGET(mshzf,hilighton);
SAVE_WIDGET(mshzf,hitettype);
SAVE_WIDGET(mshzf,tethi);
SAVE_WIDGET(mshzf,elehi);
SAVE_WIDGET(mshzf,verthi);
SAVE_WIDGET(mshzf,cnnxhi);
SAVE_WIDGET(mshzf,verthi);
SAVE_WIDGET(mshzf,cabhi);
SAVE_WIDGET(mshzf,attachtype);
//vector tab
SAVE_WIDGET(mshzf,veconbut);
SAVE_WIDGET(mshzf,veccstype);
SAVE_WIDGET(mshzf,veclength);
SAVE_WIDGET(mshzf,vecautocal);
SAVE_WIDGET(mshzf,vecstride);
SAVE_WIDGET(mshzf,vecstoch);
SAVE_WIDGET(mshzf,vecheads);
SAVE_WIDGET(mshzf,veclenmag);
SAVE_WIDGET(mshzf,veclenscalar);
SAVE_WIDGET(mshzf,veclenfix);
SAVE_WIDGET(mshzf,veccolmag);
SAVE_WIDGET(mshzf,veccolscalar);
SAVE_WIDGET(mshzf,veccolfix);
SAVE_WIDGET(mshzf,veccolmin);
SAVE_WIDGET(mshzf,veccolmax);
if(mwtb->vecdata){
   mshzf << "VEC_FIXED_COLOR = ";
   save_colour( mshzf, mwtb->vecdata->colour() );
   mshzf << endl;
}
//light tab
SAVE_WIDGET(mshzf,lightx);
SAVE_WIDGET(mshzf,lighty);
SAVE_WIDGET(mshzf,lightz);
SAVE_WIDGET(mshzf,ambientslide);
SAVE_WIDGET(mshzf,specularslide);
SAVE_WIDGET(mshzf,diffuseslide);
SAVE_WIDGET(mshzf,showLightDir);
SAVE_WIDGET(mshzf,facetshadBut);
SAVE_WIDGET(mshzf,illBut);
//surface tab
SAVE_WIDGET(mshzf,surfvisbut);
SAVE_WIDGET(mshzf,surfoutlinebut);
SAVE_WIDGET(mshzf,surffillbut);
// Aux Grid tab
SAVE_WIDGET(mshzf,auxgriddispbut);
SAVE_WIDGET(mshzf,auxcstype);
SAVE_WIDGET(mshzf,auxmincolval);
SAVE_WIDGET(mshzf,auxmaxcolval);
SAVE_WIDGET(mshzf,auxnumcolev);
SAVE_WIDGET(mshzf,auxautocalibratebut);
SAVE_WIDGET(mshzf,auxptdat);
SAVE_WIDGET(mshzf,auxptsize);
SAVE_WIDGET(mshzf,auxptstyle);
SAVE_WIDGET(mshzf,auxlinedat);
SAVE_WIDGET(mshzf,auxlinewidth);
SAVE_WIDGET(mshzf,auxlinestyle);
SAVE_WIDGET(mshzf,auxsurfdat);
SAVE_WIDGET(mshzf,auxsurfline);
SAVE_WIDGET(mshzf,auxsurfstyle);
SAVE_WIDGET(mshzf,auxvoldat);
SAVE_WIDGET(mshzf,auxvolline);
SAVE_WIDGET(mshzf,auxvolstyle);
if(mwtb->auxGrid){
  mshzf << "AUX_GRID_COLOURS = 4" << endl;
  save_colour(mshzf, mwtb->auxGrid->color(Vertex) );
  mshzf << " ";
  save_colour(mshzf, mwtb->auxGrid->color(Cnnx) );
  mshzf << " ";
  save_colour(mshzf, mwtb->auxGrid->color(SurfEle) );
  mshzf << " ";
  save_colour(mshzf, mwtb->auxGrid->color(VolEle) );
  mshzf << endl;
}
// colour scale
SAVE_WIDGET(mshzf,autocalibratebut);
SAVE_WIDGET(mshzf,mincolval);
SAVE_WIDGET(mshzf,maxcolval);
SAVE_WIDGET(mshzf,numcolev);
SAVE_WIDGET(mshzf,cstype);
// animation
SAVE_WIDGET(mshzf,tmslider);
SAVE_WIDGET(mshzf,frameskip);
SAVE_WIDGET(mshzf,animdelay);

mshzf << "SURFACE_COLOURS = " << mwtb->model->numSurf() << endl;
for( int i=0; i<mwtb->model->numSurf(); i++ ) {
  save_colour( mshzf, mwtb->model->surface(i)->fillcolor() );
  mshzf << " ";
  save_colour( mshzf, mwtb->model->surface(i)->outlinecolor() );
  mshzf << " " << mwtb->model->surface(i)->visible();
  mshzf << " " << mwtb->model->surface(i)->filled();
  mshzf << " " << mwtb->model->surface(i)->outline();
  mshzf << " " << mwtb->model->surface(i)->diffuse();
  mshzf << " " << mwtb->model->surface(i)->specular();
  mshzf << " " << mwtb->model->surface(i)->shiny();
  mshzf << " " << mwtb->model->surface(i)->backlight(); 
  mshzf << endl;
}

mshzf << "REGION_SIZE = " << mwtb->model->_numReg << endl;
for( int i=0; i<mwtb->model->_numReg; i++ ) {
  RRegion *r =  mwtb->model->region(i);
  mshzf << r->size(Vertex) << " ";
  mshzf << r->size(Cable) << " ";
  mshzf << r->size(Cnnx) << endl;
}

mshzf << "stride =";
mshzf << " " << mwtb->stride(Vertex);
mshzf << " " << mwtb->stride(Cable);
mshzf << " " << mwtb->stride(Cnnx) << endl;

mshzf << "REGION_3D = " << mwtb->model->_numReg << endl;
for( int i=0; i<mwtb->model->_numReg; i++ ) {
  RRegion *r =  mwtb->model->region(i);
  mshzf << r->threeD(Vertex) << " ";
  mshzf << r->threeD(Cable) << " ";
  mshzf << r->threeD(Cnnx) << endl;
}

mshzf << "REGION_COLOURS = " << mwtb->model->_numReg << endl;
for( int i=0; i<mwtb->model->_numReg; i++ ) {
  save_colour( mshzf, mwtb->model->region(i)->get_color(Vertex) );
  mshzf << " " << mwtb->model->region(i)->show(Vertex) << " ";
  save_colour( mshzf, mwtb->model->region(i)->get_color(Cable) );
  mshzf << " " << mwtb->model->region(i)->show(Cable) << " ";
  save_colour( mshzf, mwtb->model->region(i)->get_color(Cnnx) );
  mshzf << " " << mwtb->model->region(i)->show(Cnnx) << " " 
        << mwtb->model->region(i)->visible() << endl; 
}
mshzf << "BGD_COLOUR = " << (mwtb->bgd())[1] << endl;

mshzf << "ISOLINE_COLOUR = ";
save_colour( mshzf, mwtb->isosurfwin ->islColor() );
mshzf << endl;
SAVE_WIDGET( mshzf, mwtb->isosurfwin->isolineVal0 );
SAVE_WIDGET( mshzf, mwtb->isosurfwin->isolineVal1 );
SAVE_WIDGET( mshzf, mwtb->isosurfwin->isoNumLines );
SAVE_WIDGET( mshzf, mwtb->isosurfwin->isolineThick );
SAVE_WIDGET( mshzf, mwtb->isosurfwin->islDatify );
SAVE_WIDGET( mshzf, mwtb->isosurfwin->isl3D );
SAVE_WIDGET( mshzf, mwtb->isosurfwin->isolineOn );
SAVE_WIDGET( mshzf, mwtb->isosurfwin->isoOn0 );
SAVE_WIDGET( mshzf, mwtb->isosurfwin->isoval0 );
SAVE_WIDGET( mshzf, mwtb->isosurfwin->opacity0 );
SAVE_WIDGET( mshzf, mwtb->isosurfwin->isoOn1 );
SAVE_WIDGET( mshzf, mwtb->isosurfwin->isoval1 );
SAVE_WIDGET( mshzf, mwtb->isosurfwin->opacity1 );
SAVE_WIDGET( mshzf, mwtb->isosurfwin->isoLineRestrict );

mshzf << "ISOSURF_COLOUR 0 = ";
save_colour( mshzf, mwtb->isosurfwin->issColor(0) );
mshzf << endl;
mshzf << "ISOSURF_COLOUR 1 = ";
save_colour( mshzf, mwtb->isosurfwin->issColor(1) );
mshzf << endl;

SAVE_WIDGET( mshzf, mwtb->deadData->minValid );
SAVE_WIDGET( mshzf, mwtb->deadData->minValidVal );
SAVE_WIDGET( mshzf, mwtb->deadData->maxValid );
SAVE_WIDGET( mshzf, mwtb->deadData->maxValidVal );
SAVE_WIDGET( mshzf, mwtb->deadData->deadopac );
SAVE_WIDGET( mshzf, mwtb->deadData->showDeadData );
mshzf << "DEAD_COLOUR = ";
save_colour( mshzf, mwtb->cs->deadColour() );
mshzf << endl;

mshzf << "REF_SYNC_ROTATION = ";
mshzf  << mwtb->model->syncRefRot() << endl;

mshzf << endl;} {}
  }
  Function {save_colour( ofstream&ofs, const GLfloat *col )} {} {
    code {for( int c=0; c<3; c++ ) ofs << col[c] << " ";
ofs << col[3];} {}
  }
  Function {pick_surf_color(Object_t ot, string winlab, surfColourChoice *cc=NULL)} {open return_type {surfColourChoice *}
  } {
    code {int msz = surflist->nitems();

if( !msz || !surflist->nchecked()) return cc;

GLfloat *col;
GLfloat matprop[4];
bool one=false;

for( int mi=0; mi<surflist->nitems(); mi++ ) 
 if( surflist->checked(mi+1) ) {
       one = true;
       winlab += mwtb->model->surface(mi)->label();
       winlab += " ";
       col = mwtb->get_color(ot, mi);
       mwtb->model->get_mat( mi, matprop[0], matprop[1], matprop[2], matprop[3] );
       break;
  }
  
if( !one ) return cc;
 
if( !cc ) {
  cc = new surfColourChoice( col, matprop, surflist, ot, mwtb );
  
  cc->window->label(winlab.c_str());
}

cc->rgb_choice->rgb( col[0], col[1], col[2] );
cc->rgb_choice->do_callback();
cc->rgb_choice->redraw();
cc->opacity->value(col[3]);

cc->window->show();
return cc;} {}
  }
  Function {restore_state(const char* fname=NULL)} {open
  } {
    code {ifstream mshzf;
if( fname==NULL ) {
  char *fn=fl_file_chooser("Meshalyzer state file", "*.mshz", NULL );
  if( fn==NULL) return;
  mshzf.open(fn);
} else
  mshzf.open(fname);

int BUFLEN=1024;
char buf[BUFLEN];
float r, g, b, a;

while( mshzf.getline( buf, BUFLEN ) ) {
  
  float val;
  char  var[1024];
  if( sscanf( buf, "%s = %f", var, &val ) <1 )
    continue;
  if( !strcmp( var, "HELD_CURVES" ) ) {
    istringstream iss( buf );
    string curve;
    iss >> curve; // read HELD_CURVES =
    iss >> curve;
    while( iss >> curve ) {
      mwtb->highlight(Vertex,atoi(curve.c_str()));
      mwtb->timeplot();
      mwtb->timeplotter->graph->copy_curve(0);
    }
    continue;
  }
  if( !strcmp( var, "TRACKBALL" ) ) {
	mwtb->trackball.read(mshzf); 
	continue;
  } 
  if( !strcmp( var, "DATA_OPACITY" ))  {
	mwtb->dataopac->read(mshzf); 
	continue;
  } 
  if( !strcmp( var, "CLIPPING" ))  {
	mwtb->cplane->read(mshzf); 
	continue;
  } 
  if( !strcmp( var, "SURFACE_COLOURS" ) ) {
    for( int i=0; i<val; i++ ) {
      mshzf.getline(buf, BUFLEN);
      if( i >= mwtb->model->numSurf() ){
        continue;
      }
      istringstream slin(buf);
      slin >> r >> g >> b >> a;
      mwtb->model->surface(i)->fillcolor(r,g,b,a);
      slin >> r >> g >> b >> a;
      mwtb->model->surface(i)->outlinecolor(r,g,b,a);
      slin >> r >> g >> b;
      mwtb->model->surface(i)->visible(int(r));
      mwtb->model->surface(i)->filled(int(g));
      mwtb->model->surface(i)->outline(int(b));
      slin >> r >> g >> b >> a;
      if( slin.fail() ) {
       r = 0.7;
       g = 0.8;
       b = 64;
       a = 0.5;
      } 
      mwtb->model->surface(i)->diffuse(r);
      mwtb->model->surface(i)->specular(g);
      mwtb->model->surface(i)->shiny(b);
      mwtb->model->surface(i)->backlight(a);
    }
    continue;
  } 
  if( !strcmp( var, "REGION_COLOURS" ) ) {
    bool  v;
    for( int i=0; i<val; i++ ) {
      if( i >= mwtb->model->_numReg ) {
         mshzf.getline( buf, BUFLEN );
         continue;
      }     
      mshzf >> r >> g >> b >> a >> v;
      mwtb->model->region(i)->set_color(Vertex, r, g, b, a );
      mwtb->model->region(i)->show( Vertex, v );
      mshzf >> r >> g >> b >> a >> v;
      mwtb->model->region(i)->set_color(Cable, r, g, b, a );   
      mwtb->model->region(i)->show( Cable, v );
      mshzf >> r >> g >> b >> a >> v;
      mwtb->model->region(i)->set_color(Cnnx, r, g, b, a ); 
      mwtb->model->region(i)->show( Cnnx, v );
      mshzf >> v;
      mwtb->model->region(i)->visible(v);
      mshzf.getline( buf, BUFLEN );
    }
	continue;
  }
  if( !strcmp( var, "REGION_3D" ) ) {
    bool  v;
    for( int i=0; i<val; i++ ) {
      if( i >= mwtb->model->_numReg ) {
         mshzf.getline( buf, BUFLEN );
         continue;
      }     
      mshzf >> v;
      mwtb->model->region(i)->threeD( Vertex, v );
      mshzf >> v;
      mwtb->model->region(i)->threeD( Cable, v );
      mshzf >> v;
      mwtb->model->region(i)->threeD( Cnnx, v );
      mshzf.getline( buf, BUFLEN );
    }
    continue;
  } 
  if( !strcmp( var, "REGION_SIZE" ) ) {
    for( int i=0; i<val; i++ ) {
      if( i >= mwtb->model->_numReg ) {
         mshzf.getline( buf, BUFLEN );
      } else {
        float s;
        mshzf >> s;
        mwtb->model->region(i)->size( Vertex, s );
        mshzf >> s;
        mwtb->model->region(i)->size( Cable, s );
        mshzf >> s;
        mwtb->model->region(i)->size( Cnnx, s );
        mshzf.getline( buf,BUFLEN );
      }
    }
   continue;
  } 
  if( !strcmp( var, "stride" ) ) {
    int vs, cbs, cxs;
    sscanf( buf, "%*s = %d %d %d", &vs, &cbs, &cxs );
    mwtb->stride( Vertex, vs );
    mwtb->stride( Cable, cbs );
    mwtb->stride( Cnnx, cxs );
    continue;
  } 
  TEST_MENUVAR( read_recalibrate, var, val, mainbar )  
  TEST_MENUVAR( revdraworder, var, val, mainbar )  
  TEST_MENUVAR( norot, var, val, mainbar )  
  TEST_MENUVAR( transBgd, var, val, mainbar )  
  TEST_MENUVAR( vertdisp, var, val, datadest )
  TEST_MENUVAR( cabledisp, var, val, datadest )
  TEST_MENUVAR( cnnxdisp, var, val, datadest )
  TEST_MENUVAR( surfedgedisp, var, val, datadest )
  TEST_MENUVAR( surfdisp, var, val, datadest )
  TEST_MENUVAR( voldisp, var, val, datadest )
  TEST_RADIO( brcutNone, var, int(val), mainbar )
  TEST_RADIO( brcutPM1, var, int(val), mainbar )
  TEST_RADIO( brcut01, var, int(val), mainbar )
  TEST_RADIO( brcutPMpi, var, int(val), mainbar )
  TEST_RADIO( brcut02pi, var, int(val), mainbar )
  TEST_VAR( draw_axes, var, int(val) )  
  TEST_RADIO( dispAsSurf, var, int(val), dispAsSurf ) 
  TEST_RADIO( dispAsVol, var, int(val), dispAsSurf )
  TEST_VAR( vertbut, var, int(val) )  
  TEST_VAR( cabbut, var, int(val) )  
  TEST_VAR( cnnxbut, var, int(val) )    
  TEST_VAR( hilighton, var, int(val) ) 
  TEST_CHOICE( hitettype, var, int(val) ) 
  TEST_VAR( tethi, var, int(val) ) 
  TEST_VAR( elehi, var, int(val) ) 
  TEST_VAR( verthi, var, int(val) ) 
  TEST_VAR( cnnxhi, var, int(val) ) 
  TEST_VAR( cabhi, var, int(val) ) 
  TEST_CHOICE( attachtype, var, int(val) ) 
  if( mwtb->vecdata != NULL ) {
    if( !strcmp( var, "VEC_FIXED_COLOR" ) ) {
      sscanf( buf, "%*s = %f %f %f %f", &r, &g, &b, &a );;
      mwtb->vecdata->colour(r,g,b,a);;
      continue;
    } 
    TEST_CHOICE( veccstype, var, int(val) )
    TEST_VAR( veconbut, var, int(val) ) 
    TEST_VAR( veclength, var, val ) 
    TEST_VAR( vecautocal, var, int(val) ) 
    TEST_VAR( vecstride, var, int(val) ) 
    TEST_VAR( vecstoch, var, int(val) )
    TEST_VAR( vecheads, var, int(val) ) 
    TEST_VAR( veccolmin, var, val )
    TEST_VAR( veccolmax, var, val )
    TEST_RADIO( veclenmag,    var, int(val), veclengthdeterm ) 
    TEST_RADIO( veclenscalar, var, int(val), veclengthdeterm ) 
    TEST_RADIO( veclenfix,    var, int(val), veclengthdeterm ) 
    TEST_RADIO( veccolmag,    var, int(val), veccoldeterm ) 
    TEST_RADIO( veccolscalar, var, int(val), veccoldeterm ) 
    TEST_RADIO( veccolfix,    var, int(val), veccoldeterm ) 
 } else {
    IGNORE_VAR( VEC_FIXED_DATA, var )
    IGNORE_VAR( veccstype, var )
    IGNORE_VAR( veconbut, var ) 
    IGNORE_VAR( veclength, var ) 
    IGNORE_VAR( vecautocal, var ) 
    IGNORE_VAR( vecstride, var ) 
    IGNORE_VAR( vecstoch, var ) 
    IGNORE_VAR( vecheads, var ) 
    IGNORE_VAR( veccolmin, var ) 
    IGNORE_VAR( veccolmax, var ) 
    IGNORE_VAR( veclenmag, var ) 
    IGNORE_VAR( veclenscalar, var )
    IGNORE_VAR( veclenfix, var )
    IGNORE_VAR( veccolmag, var ) 
    IGNORE_VAR( veccolscalar, var )
    IGNORE_VAR( veccolfix, var )
  }
  TEST_VAR( lightx, var, val ) 
  TEST_VAR( lighty, var, val ) 
  TEST_VAR( lightz, var, val ) 
  TEST_VAR( ambientslide, var, val ) 
  TEST_VAR( specularslide, var, val ) 
  TEST_VAR( diffuseslide, var, val )
  TEST_VAR( showLightDir, var, int(val) ) 
  TEST_VAR( facetshadBut, var, int(val) ) 
  TEST_VAR( illBut, var, int(val) )  
  TEST_VAR( surfvisbut, var, int(val) ) 
  TEST_VAR( surfoutlinebut, var, int(val) ) 
  TEST_VAR( surffillbut, var, int(val) ) 
  TEST_VAR( autocalibratebut, var, int(val) ) 
  TEST_VAR( mincolval, var, val ) 
  TEST_VAR( maxcolval, var, val ) 
  TEST_VAR( numcolev, var, int(val) ) 
  TEST_CHOICE( cstype, var, int(val) ) 
  TEST_VAR( tmslider, var, int(val) ) 
  TEST_VAR( frameskip, var, int(val) ) 
  TEST_VAR( animdelay, var, int(val) ) 
  if( mwtb->auxGrid ) {
	TEST_VAR( auxgriddispbut, var, int(val) );
	TEST_CHOICE( auxcstype, var, int(val) );
	TEST_VAR( auxmincolval, var, val );
	TEST_VAR( auxmaxcolval, var, val );
	TEST_VAR( auxnumcolev, var, int(val) );
	TEST_VAR( auxautocalibratebut, var, int(val) );
	TEST_VAR( auxptdat, var, int(val) );
	TEST_VAR( auxptsize, var, val );
	TEST_CHOICE( auxptstyle, var, int(val) );
	TEST_VAR( auxlinedat, var, int(val) );
	TEST_VAR( auxlinewidth, var, val );
	TEST_CHOICE( auxlinestyle, var, int(val) );
	TEST_VAR( auxsurfdat, var, int(val) );
	TEST_VAR( auxsurfline, var, val );
	TEST_CHOICE( auxsurfstyle, var, int(val) ); 
	TEST_VAR( auxvoldat, var, int(val) );
	TEST_VAR( auxvolline, var, val );
	TEST_CHOICE( auxvolstyle, var, int(val) ); 
  } else {
	IGNORE_VAR( auxgriddispbut, var );
	IGNORE_VAR( auxcstype, var );
	IGNORE_VAR( auxmincolval, var );
	IGNORE_VAR( auxmaxcolval, var );
	IGNORE_VAR( auxnumcolev, var );
	IGNORE_VAR( auxautocalibratebut, var );
	IGNORE_VAR( auxptdat, var );
	IGNORE_VAR( auxptsize, var );
	IGNORE_VAR( auxptstyle, var );
	IGNORE_VAR( auxlinedat, var );
	IGNORE_VAR( auxlinewidth, var );
	IGNORE_VAR( auxlinestyle, var );
	IGNORE_VAR( auxsurfdat, var );
	IGNORE_VAR( auxsurfline, var );
	IGNORE_VAR( auxsurfstyle, var );
	IGNORE_VAR( auxvoldat, var );
	IGNORE_VAR( auxvolline, var );
	IGNORE_VAR( auxvolstyle, var );
  }
  if( !strcmp( var, "AUX_GRID_COLOURS" ) ) {
    if( mwtb->auxGrid ) {
      float c[4];
      mshzf >> c[0] >> c[1] >> c[2] >> c[3];
      mwtb->auxGrid->color( Vertex, c );
      mshzf >> c[0] >> c[1] >> c[2] >> c[3];
      mwtb->auxGrid->color( Cnnx, c );
      mshzf >> c[0] >> c[1] >> c[2] >> c[3];
      mwtb->auxGrid->color( SurfEle, c );
      mshzf >> c[0] >> c[1] >> c[2] >> c[3];
      mwtb->auxGrid->color( VolEle, c );
      mshzf.getline( buf,BUFLEN );
    }
    continue;
  }
  TEST_VAR( mwtb->isosurfwin->isolineVal0, var, val )
  TEST_VAR( mwtb->isosurfwin->isolineVal1, var, val )
  TEST_VAR( mwtb->isosurfwin->isoNumLines, var, int(val) )
  TEST_VAR( mwtb->isosurfwin->isolineThick, var, int(val) )
  TEST_VAR( mwtb->isosurfwin->islDatify, var, int(val) )
  TEST_VAR( mwtb->isosurfwin->isl3D, var, int(val) )
  TEST_VAR( mwtb->isosurfwin->isolineOn, var, int(val) )
  TEST_VAR( mwtb->isosurfwin->isoval0, var, val )
  TEST_VAR( mwtb->isosurfwin->opacity0, var, val )
  TEST_VAR( mwtb->isosurfwin->isoOn0, var, val )
  TEST_VAR( mwtb->isosurfwin->isoval1, var, val )
  TEST_VAR( mwtb->isosurfwin->opacity1, var, val )
  TEST_VAR( mwtb->isosurfwin->isoOn1, var, val )
  TEST_VAR( mwtb->isosurfwin->isoLineRestrict, var, val )

  if( !strcmp( var, "ISOLINE_COLOUR" ) ){
    sscanf( buf, "%*s = %f %f %f %f", &r, &g, &b, &a );
    mwtb->isosurfwin->islColor(r,g,b,a);
    continue;
  }
  if( !strcmp( var, "ISOSURF_COLOUR" ) ){
    int s;
    sscanf( buf, "%*s %d = %f %f %f %f", &s, &r, &g, &b, &a );
    mwtb->isosurfwin->issColor(s,r,g,b,a);
    continue;
  }
  if( !strcmp( var, "REF_SYNC_ROTATION" ) ){
    sscanf( buf, "%*s = %f %f %f %f", &r, &g, &b, &a );
    mwtb->model->syncRefRot(Quaternion(r,g,b,a));
    continue;
  }

  TEST_VAR( mwtb->deadData->minValid, var, val )
  TEST_VAR( mwtb->deadData->minValidVal, var, val ) 
  TEST_VAR( mwtb->deadData->maxValid, var, val )
  TEST_VAR( mwtb->deadData->maxValidVal, var, val )
  TEST_VAR( mwtb->deadData->deadopac, var, val )
  TEST_VAR( mwtb->deadData->showDeadData, var, val )
  if( !strcmp( var, "DEAD_COLOUR" ) ){
    sscanf( buf, "%*s = %f %f %f %f", &r, &g, &b, &a );
    mwtb->deadData->dead_color->rgb(r,g,b);
    mwtb->deadData->dead_color->do_callback();
    mwtb->deadData->deadApp->do_callback();
    continue;
  }

 TEST_VAR( mwtb->deadData->minValid, var, val )
 
  if( !strcmp( "BGD_COLOUR", var )) { mwtb->bgd(val); continue; }

  cerr << "Unknown variable specified: " << var << endl;
}
mwtb->lights(illBut->value());} {}
  }
  Function {surfselected(vector<int>& lst)} {} {
    code {lst.clear();
for( int i=1; i<=surflist->nitems(); i++ )
  if( surflist->checked(i) )
    lst.push_back(i-1);} {}
  }
  Function {refresh_surflist(int state=1)} {} {
    code {surflist->clear(); 
for( int s=0; s<mwtb->model->numSurf(); s++ ) {
    surflist->add(mwtb->model->surface(s)->label().c_str(),state);
  }
  elehi->maximum(mwtb->model->number(SurfEle)-1);
  mwtb->redraw();
  surflist->redraw();} {}
  }
  Function {dispVertVal(double d)} {} {
    code {vertvalout->value(d);} {}
  }
  Function {write_surfaces(int start )} {} {
    code {char *fn;
string surffn=mwtb->model->file();
surffn += "surf";
if( fn=fl_file_chooser( "Save surface file as:", "*.{tri,surf}*", surffn.c_str() )){
  fl_cursor(FL_CURSOR_WAIT );
  ofstream outf(fn);
  for( int i=start; i<mwtb->model->numSurf(); i++ ) 
    mwtb->model->surface(i)->to_file(outf);
  fl_cursor(FL_CURSOR_DEFAULT);
  mwtb->redraw();
}} {}
  }
  Function {update_vecdata(VecData *vd)} {} {
    code {if( vd->length_det()==Vector ) {
  veclenmag->setonly();
  veclenmag->do_callback(veclengthdeterm);
} else if( vd->length_det()==Scalar ) {
  veclenscalar->setonly();
  veclenscalar->do_callback(veclengthdeterm);
} else {
  veclenfix->setonly();
  veclenfix->do_callback(veclengthdeterm);
} 
if( vd->colour_det()==Vector ) {
  veccolmag->setonly();
  veccolmag->do_callback(veccoldeterm);
} else if( vd->colour_det()==Scalar ) {
  veccolscalar->setonly();
  veccolscalar->do_callback(veccoldeterm);
} else {
  veccolfix->setonly();
  veccolfix->do_callback(veccoldeterm);
} 

if( vd->have_scalar() ) {
  veccolscalar->activate();
  veclenscalar->activate();
} else { 
   veccolscalar->deactivate();
   veclenscalar->deactivate();
}

if( vd->size()/int(vecstride->value())>MAX_INIT_VECS ) {
  int stride = vd->size()/(MAX_INIT_VECS)+1;
  vecstride->value(stride);
  vd->stride(stride);
}} {}
  }
}

class ProgInfo {} {
  Function {ProgInfo()} {open
  } {
    Fl_Window proginfo {
      label {Progam Version} open
      xywh {1082 25 560 570} type Single color 7 hide
    } {
      Fl_Text_Display infotxt {
        image {meshlogo.jpg} xywh {5 140 550 430} box NO_BOX
      }
    }
  }
}

class ObjProps {open
} {
  Function {ObjProps( TBmeshWin* wtb, Object_t o ):mwtb(wtb),obj(o)} {open
  } {
    Fl_Window win {open
      xywh {1044 451 220 245} type Single box ENGRAVED_BOX hide
    } {
      Fl_Check_Button thrD {
        label {3D }
        callback {bool *sel = mwtb->contwin->regselected();
for( int i=0; i<nreg; i++ )
  if( sel[i] )
    mwtb->threeD( obj, i, static_cast<bool>(thrD->value()) );
delete sel;}
        xywh {15 18 45 27} down_box DOWN_BOX align 24
      }
      Fl_Value_Input stride {
        label Stride
        callback {mwtb->stride( obj, int(stride->value()) );}
        xywh {170 18 30 28} align 1 value 1
      }
      Fl_Value_Input sizeinp {
        label Size
        callback {bool *sel = mwtb->contwin->regselected();
for( int i=0; i<nreg; i++ )
  if( sel[i] )
     mwtb->size(obj, i, float(o->value()) );
delete sel;}
        xywh {70 18 70 28} align 1 maximum 10000 step 0.1 value 1
      }
      Fl_Box color {
        label Colour
        callback {uchar ri = o->r()*255.;
uchar bi = o->b()*255.;
uchar gi = o->g()*255.;
opacity->selection_color(fl_rgb_color(ri,gi,bi));
opacity->redraw();}
        xywh {10 53 200 95}
        code0 {\#include <FL/Fl_Color_Chooser.H>}
        class Fl_Color_Chooser
      }
      Fl_Value_Slider opacity {
        label Opacity
        xywh {10 160 200 20} type {Horz Fill} selection_color 219 value 1 textsize 14
      }
      Fl_Button {} {
        label Done
        callback {win->hide();}
        xywh {135 205 75 30} color 204
      }
      Fl_Return_Button {} {
        label Apply
        callback {bool *sel = mwtb->contwin->regselected();
c[0] = color->r();
c[1] = color->g();
c[2] = color->b();
c[3] = opacity->value();

for( int r=0; r<nreg; r++ )
  if( sel[r] ) 
    mwtb->set_color( obj, r, c[0], c[1], c[2], c[3] );

mwtb->redraw();
delete sel;}
        xywh {5 205 125 30} color 133
      }
    }
    code {string lab = objnames[obj];
win->label(lab.c_str());
nreg = mwtb->contwin->reglist->nitems();
update();} {}
  }
  decl {TBmeshWin *mwtb;} {private local
  }
  decl {Object_t obj;} {private local
  }
  decl {int nreg;} {private local
  }
  decl {GLfloat c[4];} {private local
  }
  Function {update()} {open
  } {
    code {bool *sel = mwtb->contwin->regselected();
for( int i=0; i<nreg; i++ )
  if( sel[i] ) {
    thrD->value( mwtb->threeD( obj, i ) );
    stride->value( mwtb->stride( obj ) );
    sizeinp->value( mwtb->size( obj, i ) );
    GLfloat *c = mwtb->get_color( obj, i );
    color->rgb(c[0],c[1],c[2]);
    opacity->value(c[3]);
    color->do_callback();
    color->redraw();
  }
delete sel;} {}
  }
}
