# data file for the Fltk User Interface Designer (fluid)
version 1.0300 
header_name {.h} 
code_name {.cc}
decl {\#include "Surfaces.h"} {public local
} 

decl {\#include <GL/gl.h>} {public local
} 

decl {\#include <vector>} {private local
} 

decl {class TBmeshWin;} {public local
} 

decl {class IsoSurface;} {public local
} 

decl {\#define SAVE_WIDGET(f,a) f<<\#a<<" = "<<double(a->value())<<endl;} {private local
} 

decl {\#define TEST_VAR(A,B,C) if(!strcmp(\#A,B)){A->value(C);A->do_callback();continue;}} {private local
} 

decl {\#define TEST_CHOICE(A,B,C) if(!strcmp(\#A,B)){A->value(C);A->mvalue()->do_callback(A);continue;}} {private local
} 

decl {\#define TEST_MENUVAR(A,B,C) if(!strcmp(\#A,B)){if(C)A->set();else A->clear();continue;}} {private local
} 

decl {\#define IGNORE_VAR(A,B) if(!strcmp(\#A,B)){continue;}} {private local
} 

decl {\#include "Model.h"} {public local
} 

decl {\#include <set>} {private local
} 

decl {\#include "colourchoice.h"} {private local
} 

class Meshwin {} {
  Function {Meshwin()} {open
  } {
    Fl_Window winny {
      label trimesh open
      xywh {60 84 455 455} type Double hide
    } {
      Fl_Box trackballwin {
        xywh {0 0 455 455}
        code0 {\#include "TBmeshWin.h"}
        class TBmeshWin
      }
    }
    code {winny->resizable(trackballwin);
winny->size_range(50,50,1200,1200,5,5,1);} {}
  }
  class UserInterface {open
  } {}
} 

class Controls {open
} {
  Function {Controls()} {open
  } {
    Fl_Window window {
      label {Meshalyzer Controls} open
      xywh {1402 58 350 650} type Double box UP_BOX
      code0 {\#include <FL/Fl_Color_Chooser.H>}
      code1 {\#include "VecData.h"} visible
    } {
      Fl_Menu_Bar mainbar {
        xywh {0 -1 350 30} labelcolor 1
      } {
        Submenu {} {
          label File
          xywh {0 0 100 20}
        } {
          MenuItem {} {
            label {Add surface}
            callback {char *fn=fl_file_chooser("Surface", "*.{tris,surf,tri}",NULL);
int sn;
if( fn != NULL ) {
  if( (sn=mwtb->add_surface(fn))>0 ) {
    for( int s=0; s<sn; s++ ) {
      surflist->add(mwtb->model->surface(surflist->nitems())->label().c_str(),1);
    }
    elehi->maximum(mwtb->model->number(SurfEle)-1);
    mwtb->redraw();
    surflist->redraw();
  }
}}
            xywh {0 0 100 20}
          }
          MenuItem {} {
            label {Compute surfaces}
            callback {int nsa=mwtb->model->add_region_surfaces();
int ns = mwtb->model->numSurf();
for( int i=ns-nsa; i<ns; i++ )  
  surflist->add( mwtb->model->surface(i)->label().c_str(),1);
surflist->redraw();
char *fn;
string surffn=mwtb->model->file();
surffn += "surf";
if( fn=fl_file_chooser( "Save surface file as:", "*.{tri,surf}*", surffn.c_str() )){
  fl_cursor(FL_CURSOR_WAIT );
  ofstream outf(fn);
  for( int i=ns-nsa; i<ns; i++ ) {
    SurfaceElement *e;
    outf << mwtb->model->surface(i)->num() << endl;
    for( int j=0; j<mwtb->model->surface(i)->num();j++ ) {
      e = mwtb->model->element(i,j);
      const int* n=e->obj();
      if( e->ptsPerObj()==3 ) 
        outf << "Tr";
      else
        outf << "Qd";
      for( int k=0; k< e->ptsPerObj(); k++ )
        outf << " " << n[k];
      outf << endl;
    }
  }
  fl_cursor(FL_CURSOR_DEFAULT);
  mwtb->redraw();
}}
            xywh {0 0 30 20} divider
          }
          MenuItem {} {
            label {Read data}
            callback {char *fn=fl_file_chooser("Data file","*{out,dat}*",NULL);
if(fn != NULL) mwtb->get_data(fn,tmslider);
mincolval->value(mwtb->cs->min());
maxcolval->value(mwtb->cs->max());}
            xywh {0 0 100 20}
            code0 {\#include <FL/Fl_File_Chooser.H>}
          }
          MenuItem {} {
            label {Read IGB data}
            callback {char *fn=fl_file_chooser("Data file","*igb*",NULL);
if(fn != NULL) mwtb->get_data(fn,tmslider);
mincolval->value(mwtb->cs->min());
maxcolval->value(mwtb->cs->max());}
            xywh {20 20 100 20}
            code0 {\#include <FL/Fl_File_Chooser.H>}
          }
          MenuItem {} {
            label {Read Vector Data}
            callback {if( !mwtb->getVecData(tmslider) ) {
  vectorgrp->activate();
  tabwidget->value(vectorgrp);
}}
            xywh {0 0 100 20}
          }
          MenuItem {} {
            label {Read Aux Grid}
            callback {char *fn = fl_file_chooser( "Auxiliary Grid", "*.pts_t", NULL );
if( fn && !mwtb->readAuxGrid(tmslider,fn) ) {
  auxgridgrp->activate();
  tabwidget->value(auxgridgrp);
  float val;
  if( mwtb->auxGrid->highlight_vertex(0,val))
     auxvertval->value(val);
   else
     auxvertval->value(0);
   auxhivert->value(0);
}}
            xywh {0 0 100 20}
          }
          MenuItem read_recalibrate {
            label {Recalibrate on read}
            xywh {0 0 100 20} type Toggle value 1 divider
          }
          MenuItem {} {
            label {Save transform}
            callback {char*fn;
fn=fl_file_chooser("Save Xfrm","*.xfrm",NULL);
if( fn != NULL )
 mwtb->trackball.save(fn);}
            xywh {0 0 100 20}
          }
          MenuItem {} {
            label {Read transform}
            callback {char *fn = fl_file_chooser("Xfrm file","*.xfrm",NULL);
if( fn != NULL ){
  mwtb->trackball.read(fn);
  mwtb->redraw();
}}
            xywh {0 0 100 20} divider
          }
          MenuItem {} {
            label {Save state}
            callback {save_state();}
            xywh {0 0 100 20}
          }
          MenuItem {} {
            label {Restore state}
            callback {restore_state();}
            xywh {10 10 100 20} divider
          }
          MenuItem {} {
            label Link
            callback {mwtb->tmLink->list_mesh_pids();
mwtb->tmLink->window->show();}
            xywh {0 0 30 20} divider
          }
          MenuItem {} {
            label Quit
            callback {exit(0);}
            xywh {0 0 100 20}
          }
        }
        Submenu imgmenu {
          label Image
          xywh {0 0 100 20}
        } {
          MenuItem {} {
            label {Reset transform}
            callback {mwtb->trackball.Reset();
float md = mwtb->get_maxdim();
mwtb->trackball.mouse.SetOglPosAndSize(-md, md, 2*md, 2*md );
mwtb->trackball.size = md;mwtb->redraw();}
            xywh {0 0 100 20}
          }
          Submenu {} {
            label View
            xywh {0 0 100 20}
          } {
            Submenu {} {
              label {+X}
              xywh {0 0 100 20}
            } {
              MenuItem {} {
                callback {set_rot('X',0,0);}
                image {ppaxis.png} xywh {0 0 100 20}
              }
              MenuItem {} {
                label item
                callback {set_rot('X',0,1);}
                image {npaxis.png} xywh {10 10 100 20}
              }
              MenuItem {} {
                label item
                callback {set_rot('X',0,2);}
                image {nnaxis.png} xywh {20 20 100 20}
              }
              MenuItem {} {
                label item
                callback {set_rot('X',0,3);}
                image {pnaxis.png} xywh {30 30 100 20}
              }
            }
            Submenu {} {
              label {+Y}
              xywh {5 5 100 20}
            } {
              MenuItem {} {
                callback {set_rot('Y',0,0);}
                image {ppaxis.png} xywh {10 10 100 20}
              }
              MenuItem {} {
                label item
                callback {set_rot('Y',0,1);}
                image {npaxis.png} xywh {20 20 100 20}
              }
              MenuItem {} {
                label item
                callback {set_rot('Y',0,2);}
                image {nnaxis.png} xywh {30 30 100 20}
              }
              MenuItem {} {
                label item
                callback {set_rot('Y',0,3);}
                image {pnaxis.png} xywh {40 40 100 20}
              }
            }
            Submenu {} {
              label {+Z}
              xywh {20 20 100 20}
            } {
              MenuItem {} {
                callback {set_rot('Z',0,0);}
                image {ppaxis.png} xywh {20 20 100 20}
              }
              MenuItem {} {
                label item
                callback {set_rot('Z',0,1);}
                image {npaxis.png} xywh {30 30 100 20}
              }
              MenuItem {} {
                label item
                callback {set_rot('Z',0,2);}
                image {nnaxis.png} xywh {40 40 100 20}
              }
              MenuItem {} {
                label item
                callback {set_rot('Z',0,3);}
                image {pnaxis.png} xywh {50 50 100 20}
              }
            }
            Submenu {} {
              label {-X}
              xywh {25 25 100 20}
            } {
              MenuItem {} {
                callback {set_rot('X',1,0);}
                image {ppaxis.png} xywh {10 10 100 20}
              }
              MenuItem {} {
                label item
                callback {set_rot('X',1,1);}
                image {npaxis.png} xywh {20 20 100 20}
              }
              MenuItem {} {
                label item
                callback {set_rot('X',1,2);}
                image {nnaxis.png} xywh {30 30 100 20}
              }
              MenuItem {} {
                label item
                callback {set_rot('X',1,3);}
                image {pnaxis.png} xywh {40 40 100 20}
              }
            }
            Submenu {} {
              label {-Y}
              xywh {35 35 100 20}
            } {
              MenuItem {} {
                callback {set_rot('Y',1,0);}
                image {ppaxis.png} xywh {20 20 100 20}
              }
              MenuItem {} {
                label item
                callback {set_rot('Y',1,1);}
                image {npaxis.png} xywh {30 30 100 20}
              }
              MenuItem {} {
                label item
                callback {set_rot('Y',1,2);}
                image {nnaxis.png} xywh {40 40 100 20}
              }
              MenuItem {} {
                label item
                callback {set_rot('Y',1,3);}
                image {pnaxis.png} xywh {50 50 100 20}
              }
            }
            Submenu {} {
              label {-Z}
              xywh {45 45 100 20}
            } {
              MenuItem {} {
                callback {set_rot('Z',1,0);}
                image {ppaxis.png} xywh {30 30 100 20}
              }
              MenuItem {} {
                label item
                callback {set_rot('Z',1,1);}
                image {npaxis.png} xywh {40 40 100 20}
              }
              MenuItem {} {
                label item
                callback {set_rot('Z',1,2);}
                image {nnaxis.png} xywh {50 50 100 20}
              }
              MenuItem {} {
                label item
                callback {set_rot('Z',1,3);}
                image {pnaxis.png} xywh {60 60 100 20}
              }
            }
          }
          Submenu {} {
            label {Randomly colour}
            xywh {0 0 100 20}
          } {
            MenuItem {} {
              label vertices
              callback {mwtb->randomize_color(Vertex);}
              xywh {15 15 100 20}
            }
            MenuItem {} {
              label cables
              callback {mwtb->randomize_color(Cable);}
              xywh {15 15 100 20}
            }
            MenuItem {} {
              label triangles
              callback {mwtb->randomize_color(SurfEle);}
              xywh {0 0 100 20}
            }
            MenuItem {} {
              label surfaces
              callback {mwtb->randomize_color(Surface);}
              xywh {5 5 100 20}
            }
            MenuItem {} {
              label voxele
              callback {mwtb->randomize_color(VolEle);}
              xywh {0 0 30 20}
            }
          }
          Submenu {} {
            label {Background colour}
            xywh {0 0 100 20}
          } {
            MenuItem {} {
              label White
              callback {mwtb->bgd(1);}
              xywh {0 0 100 20}
            }
            MenuItem {} {
              label Gray
              callback {mwtb->bgd(0.6);}
              xywh {10 10 100 20}
            }
            MenuItem {} {
              label Black
              callback {mwtb->bgd(0);}
              xywh {20 20 100 20}
            }
          }
          MenuItem revdraworder {
            label {Reverse draw order}
            callback {mwtb->revdraworder( (bool)(o->mvalue()->value()) );}
            xywh {0 0 100 20} type Toggle
          }
          MenuItem norot {
            label {No rotation}
            callback {mwtb->norot((bool)(o->mvalue()->value()));}
            xywh {0 0 30 20} type Toggle
          }
          MenuItem {} {
            label {Viewport Sync}
            callback {mwtb->SendViewportSyncMessage();}
            xywh {0 0 30 20}
          }
        }
        Submenu {} {
          label Data
          xywh {0 0 100 20}
        } {
          MenuItem {} {
            label Opacity
            callback {mwtb->dataopac->window->show();}
            xywh {0 0 100 20}
          }
          MenuItem {} {
            label Clipping
            callback {mwtb->cplane->window->show();}
            xywh {10 10 100 20}
          }
          MenuItem {} {
            label Isosurf
            callback {mwtb->isosurfwin->isowin->show();}
            xywh {0 0 31 20}
          }
        }
        Submenu outmenu {
          label Output
          xywh {0 0 100 20}
        } {
          Submenu {} {
            label PNG open
            xywh {5 5 100 20}
          } {
            MenuItem {} {
              label Image
              callback {char *fn = fl_file_chooser("PNG image", "*.png", "image.png" );
if( fn!=NULL)
mwtb->output_png(fn);}
              xywh {10 10 100 20}
            }
            MenuItem {} {
              label Sequence
              callback {Sequence *s=new Sequence( mwtb );
s->window->show();}
              xywh {20 20 100 20}
              code0 {\#include "Sequence.h"}
            }
            MenuItem transBgd {
              label {Transparent Bgd}
              callback {mwtb->transBgd( transBgd->value() );}
              xywh {0 0 30 20} type Toggle value 1
            }
          }
          MenuItem {} {
            label PDF
            callback {char* fn = fl_file_chooser("PDF file name", "*.pdf", "image.pdf");
if( fn==NULL) return;
mwtb->output_pdf( fn,true );}
            xywh {5 5 100 20}
          }
          MenuItem {} {
            label EPS
            callback {char* fn = fl_file_chooser("EPS file name", "*.eps", "image.eps");
if( fn==NULL) return;
mwtb->output_pdf( fn, false );}
            xywh {5 5 100 20}
          }
          MenuItem {} {
            label {Visible vertices}
            callback {mwtb->dump_vertices();}
            xywh {0 0 100 20}
          }
          Submenu recordmenu {
            label Record
            xywh {0 0 100 20}
          } {
            MenuItem {} {
              label start
              callback {if( !mwtb->recording ) {
  char* fn=fl_file_chooser( "Pick base name", "*.png", "frame.png" );
  if( fn != NULL ) {
    outmenu->labelcolor(FL_GREEN);
    redrawbut->show();
    mwtb->recording=true;
    mwtb->record_events( fn );
  }
}}
              xywh {0 0 100 20}
            }
            MenuItem {} {
              label stop
              callback {mwtb->recording = false;
outmenu->labelcolor(FL_BLACK);
redrawbut->hide();
mainbar->redraw();}
              xywh {0 0 100 20}
            }
          }
        }
        MenuItem redrawbut {
          label Redraw
          callback {mwtb->redraw();}
          xywh {0 0 100 20} labelcolor 180 hide
        }
        MenuItem {} {
          label item
          xywh {0 0 30 20} labeltype NO_LABEL
        }
        MenuItem {} {
          label item
          xywh {0 0 30 20} labeltype NO_LABEL
        }
        MenuItem {} {
          label About
          callback {proginfo->show();}
          xywh {0 0 30 20}
        }
      }
      Fl_Choice datachc {
        label {Data on}
        tooltip {use data to color which elements} xywh {75 50 110 25} down_box BORDER_BOX
        code0 {o->value(4);}
      } {
        MenuItem {} {
          label Vertices
          callback {mwtb->datify(Vertex);}
          xywh {5 5 100 20}
        }
        MenuItem {} {
          label Cables
          callback {mwtb->datify(Cable);}
          xywh {5 5 100 20}
        }
        MenuItem {} {
          label Connections
          callback {mwtb->datify(Cnnx);}
          xywh {15 15 100 20}
        }
        MenuItem {} {
          label Triangles
          callback {mwtb->datify(SurfEle);}
          xywh {5 5 100 20}
        }
        MenuItem {} {
          label Surfaces
          callback {mwtb->datify(Surface);}
          xywh {5 5 100 20}
        }
        MenuItem {} {
          label Tetrahedra
          callback {mwtb->datify(VolEle);}
          xywh {0 0 100 20}
        }
        MenuItem {} {
          label Nothing
          callback {mwtb->datify(Nothing);}
          xywh {0 0 100 20}
        }
        MenuItem {} {
          label All
          callback {mwtb->datify(All);}
          xywh {0 0 100 20}
        }
      }
      Fl_Light_Button draw_axes {
        label Axes
        callback {mwtb->redraw();}
        tooltip {toggle axs display} xywh {10 85 80 25}
      }
      Fl_Button {} {
        label {Voxele  colour}
        callback {pickcolor(VolEle, "Voxele colour");}
        xywh {95 85 85 25} labelsize 13
      }
      Fl_Group {} {
        label {Display as:}
        xywh {190 50 150 60} box ENGRAVED_BOX
      } {
        Fl_Check_Button {} {
          label Surfaces
          callback {mwtb->dispmode(asSurface);}
          xywh {195 55 90 25} type Radio down_box DIAMOND_DOWN_BOX value 1
        }
        Fl_Check_Button {} {
          label {Tetrahedral Mesh}
          callback {mwtb->dispmode(asTetMesh);}
          xywh {195 80 140 25} type Radio down_box DIAMOND_DOWN_BOX
        }
      }
      Fl_Group regiondisp {
        label Region
        xywh {10 120 330 145} box ENGRAVED_BOX align 17
      } {
        Fl_Light_Button vertbut {
          label Vertices
          callback {bool *selreg = regselected();
mwtb->showobj(Vertex,selreg,static_cast<bool>(o->value()));
delete[] selreg;}
          xywh {160 141 100 25} when 1
        }
        Fl_Light_Button cabbut {
          label Cables
          callback {bool *selreg = regselected();
mwtb->showobj(Cable,selreg,static_cast<bool>(o->value()));
delete[] selreg;}
          xywh {160 166 100 24}
        }
        Fl_Light_Button cnnxbut {
          label Connections
          callback {bool* selreg=regselected();
mwtb->showobj(Cnnx,selreg,static_cast<bool>(o->value()));
delete[] selreg;}
          xywh {160 190 100 25}
        }
        Fl_Button {} {
          label props
          callback {ObjProps *op = new ObjProps( mwtb, Vertex, reglist->nitems(), regselected() );
string lab = objnames[Vertex];
lab += " Properties";
op->win->label( lab.c_str() );
op->win->show();}
          xywh {260 140 70 25} labelsize 12
        }
        Fl_Button {} {
          label props
          callback {ObjProps *op = new ObjProps( mwtb, Cnnx, reglist->nitems(), regselected() );
string lab = objnames[Cnnx];
lab += " Properties";
op->win->label( lab.c_str() );
op->win->show();}
          xywh {260 190 70 25} labelsize 12
        }
        Fl_Light_Button visbut {
          label visible
          callback {bool *selreg=regselected();
mwtb->visibility(selreg, o->value());
delete[] selreg;}
          xywh {160 215 100 20} value 1
        }
        Fl_Button {} {
          label {select all}
          callback {reglist->check_all();}
          xywh {160 240 90 20}
        }
        Fl_Check_Browser reglist {
          xywh {25 130 120 125}
        }
        Fl_Button {} {
          label {invert select}
          callback {for( int i=0; i<=reglist->nitems(); i++ )
  reglist->checked( i, !reglist->checked(i) );}
          xywh {250 240 80 20} color 0 labelcolor 49
        }
        Fl_Button {} {
          label props
          callback {ObjProps *op = new ObjProps( mwtb, Cable, reglist->nitems(), regselected() );
string lab = objnames[Cable];
lab += " Properties";
op->win->label( lab.c_str() );
op->win->show();}
          xywh {260 165 70 25} labelsize 12
        }
      }
      Fl_Tabs tabwidget {open
        xywh {10 270 330 220} align 0
      } {
        Fl_Group hilightgrp {
          label Highlight open
          xywh {10 305 330 180} color 11 labelfont 1 labelsize 12 labelcolor 121 align 4 hide
        } {
          Fl_Value_Input tethi {
            label {VolEle:}
            callback {mwtb->highlight(VolEle,int((o->value())));}
            xywh {100 345 85 25} labeltype NO_LABEL step 1
            code0 {\#include "MyValueInput.h"}
            class MyValueInput
          }
          Fl_Value_Input elehi {
            label {:Surf Ele}
            callback {mwtb->highlight(SurfEle,static_cast<int>(o->value()));}
            xywh {190 345 85 25} align 8 step 1
            code0 {\#include "MyValueInput.h"}
            class MyValueInput
          }
          Fl_Value_Input cabhi {
            label {:Cable}
            callback {mwtb->highlight(Cable,static_cast<int>(o->value()));}
            xywh {190 375 85 25} align 8 step 1
            code0 {\#include "MyValueInput.h"}
            class MyValueInput
          }
          Fl_Value_Input verthi {
            label {Vertex:}
            callback {mwtb->highlight(Vertex,int(o->value()));
vertvalout->value(mwtb->vertex_val(int(o->value())));}
            xywh {100 405 85 25} step 1
            code0 {\#include "MyValueInput.h"}
            class MyValueInput
          }
          Fl_Value_Input cnnxhi {
            label {Connection:}
            callback {mwtb->highlight(Cnnx,static_cast<int>(o->value()));}
            xywh {100 375 85 25} step 1
            code0 {\#include "MyValueInput.h"}
            class MyValueInput
          }
          Fl_Light_Button hilighton {
            label on
            callback {mwtb->set_hilight( static_cast<bool>(o->value()) );}
            xywh {100 315 85 25}
          }
          Fl_Choice attachtype {
            label attached
            tooltip {draw which objects associated with vertex} xywh {95 435 90 25} down_box BORDER_BOX align 2 when 1
          } {
            MenuItem {} {
              label {surf eles}
              callback {mwtb->assc_obj(SurfEle);}
              xywh {5 5 100 20}
            }
            MenuItem {} {
              label Vols
              callback {mwtb->assc_obj(VolEle);}
              xywh {5 5 100 20}
            }
            MenuItem {} {
              label {filled Vols}
              callback {mwtb->assc_obj(VolEle, 1 );}
              xywh {5 5 100 20}
            }
            MenuItem {} {
              label nothing
              callback {mwtb->assc_obj(Nothing);}
              xywh {5 5 100 20}
            }
          }
          Fl_Button {} {
            label {current reg/surf}
            callback {highlight_region();}
            tooltip {set all objects to 1st in currently selected surface} xywh {190 315 85 25} labelsize 10
          }
          Fl_Button {} {
            label {?}
            callback {mwtb->hiliteinfo();}
            tooltip {display info on highlighted objects} xywh {290 315 30 25} box ROUND_UP_BOX color 133
          }
          Fl_Value_Output vertvalout {
            label {:value}
            tooltip {vertex value} xywh {190 405 85 25} color 174 align 8
          }
          Fl_Choice hitettype {open
            tooltip {display style} xywh {15 345 85 25} down_box BORDER_BOX textsize 10
          } {
            MenuItem {} {
              label {Vol Ele}
              callback {mwtb->solid_hitet(false);
mwtb->redraw();}
              xywh {5 5 100 20}
            }
            MenuItem {} {
              label {Solid Vol Ele}
              callback {mwtb->solid_hitet(true);
mwtb->redraw();}
              xywh {5 5 100 20}
            }
          }
          Fl_Button pickvert {
            label {Pick Vertex}
            callback {o->color(128);
mwtb->select_vertex();}
            tooltip {select a vertex with mouse} xywh {20 435 70 30} color 131 labelsize 12
          }
          Fl_Button {} {
            label {plot time series}
            callback {mwtb->timeplot();}
            xywh {190 435 105 30} color 124
          }
        }
        Fl_Group lightgrp {
          label Lights
          xywh {10 295 330 185} color 188 labelfont 1 labelsize 12 labelcolor 188 hide
        } {
          Fl_Value_Slider lightx {
            label {X direction}
            callback {mwtb->redraw();}
            tooltip {X component of light direction} xywh {15 330 120 20} type Horizontal selection_color 71 labelsize 12 minimum -1
          }
          Fl_Value_Slider lighty {
            label {Y direction}
            callback {mwtb->redraw();}
            tooltip {Y component of light direction} xywh {15 370 120 20} type Horizontal selection_color 190 labelsize 12 minimum -1
          }
          Fl_Value_Slider lightz {
            label {Z directtion}
            callback {mwtb->redraw();}
            tooltip {z component of light direction} xywh {15 410 120 20} type Horizontal selection_color 244 labelsize 12 minimum -1 value 1
          }
          Fl_Button {} {
            label reset
            callback {lightx->value(0);
lighty->value(0.);
lightz->value(1);
mwtb->redraw();}
            tooltip {reset light direction to default} xywh {165 305 60 20} labelsize 12
          }
          Fl_Light_Button showLightDir {
            label {show direction}
            callback {mwtb->redraw();}
            tooltip {draw an arrow indicating the light direction} xywh {125 450 100 25} labelsize 12
          }
          Fl_Button {} {
            label {zero X}
            callback {lightx->value(0);
mwtb->redraw();}
            tooltip {set x component to 0} xywh {15 305 35 20} labelsize 10
          }
          Fl_Button {} {
            label {zero Y}
            callback {lighty->value(0);
mwtb->redraw();}
            tooltip {set y component to 0} xywh {60 305 35 20} labelsize 10
          }
          Fl_Button {} {
            label {zero Z}
            callback {lightz->value(0);
mwtb->redraw();}
            tooltip {set z component to 0} xywh {105 305 35 20} labelsize 10
          }
          Fl_Light_Button illBut {
            label Illuminate
            callback {mwtb->lights((bool)o->value());}
            tooltip {turn on light} xywh {15 450 100 25} value 1 labelsize 12
          }
          Fl_Value_Slider ambientslide {
            label Ambient
            callback {mwtb->redraw();}
            tooltip {ambient lighting component level} xywh {150 330 25 95} selection_color 3 labelsize 12 value 0.2
          }
          Fl_Light_Button facetshadBut {
            label {facet shading}
            callback {mwtb->facetshade( (bool)(o->value()) );}
            tooltip {do not blend colours over surface} xywh {235 450 100 25} labelsize 12
          }
          Fl_Light_Button {} {
            label fixed
            callback {mwtb->headlamp(o->value());}
            tooltip {Fixed light - headlamp mode} xywh {240 305 60 20} value 1 labelsize 12 align 148
          }
          Fl_Value_Slider specularslide {
            label Specular
            callback {mwtb->redraw();}
            tooltip {specular lighting component level} xywh {200 330 25 95} selection_color 6 labelsize 12 value 0.65
          }
          Fl_Value_Slider diffuseslide {
            label Diffuse
            callback {mwtb->redraw();}
            tooltip {specular lighting component level} xywh {245 330 25 95} selection_color 6 labelsize 12 value 0.65
          }
          Fl_Value_Slider backintensityslide {
            label Backside
            callback {mwtb->redraw();}
            tooltip {intensity of back side of surface} xywh {300 330 25 95} selection_color 6 labelsize 12 value 0.5
          }
        }
        Fl_Group surfgrp {
          label Surface
          xywh {15 310 315 175} color 93 labelfont 1 labelsize 12 labelcolor 90 hide
        } {
          Fl_Light_Button surfvisbut {
            label visible
            callback {vector<int>lst;
surfselected(lst);
mwtb->surfVis(lst,static_cast<bool>(o->value()));}
            xywh {140 395 85 30} value 1 selection_color 2 align 16
          }
          Fl_Light_Button surfoutlinebut {
            label Outline
            callback {vector<int>lst;
surfselected(lst);
mwtb->surfOutline(lst,static_cast<bool>(o->value()));}
            xywh {140 315 85 30}
          }
          Fl_Light_Button surffillbut {
            label Filled
            callback {vector<int> lst;
surfselected(lst);
mwtb->surfFilled(lst,static_cast<bool>(o->value()));}
            xywh {235 315 85 30} value 1
          }
          Fl_Button {} {
            label {Outline colour}
            callback {pick_surf_color( SurfEle, "Outline Colour" );}
            xywh {140 355 85 30} labelsize 12
          }
          Fl_Button {} {
            label {Fill colour}
            callback {pick_surf_color( Surface, "Surface colour" );}
            xywh {235 355 85 30} labelsize 12
          }
          Fl_Check_Browser surflist {
            label {apply to}
            xywh {20 320 110 150} type Multi align 5
          }
          Fl_Button {} {
            label {select all}
            callback {surflist->check_all();
update_surfGUI(0);}
            xywh {140 445 85 25}
          }
          Fl_Button {} {
            label {invert select}
            callback {bool done=false;

for( int i=1; i<=surflist->nitems(); i++ ) {
    if( !done && !surflist->checked(i) ) {
      done = true;
      update_surfGUI(i-1);
    }
    surflist->checked(i, !surflist->checked(i));
}}
            xywh {235 445 85 25} color 0 labelfont 1 labelsize 12 labelcolor 49
          }
          Fl_Menu_Button {} {
            label delete open
            xywh {235 395 85 30} box GTK_UP_BOX color 88
          } {
            MenuItem {} {
              label really
              callback {vector<int> lst;
surfselected(lst);
for( int i=lst.size()-1; i>=0; i-- )
  mwtb->model->surfKill( lst[i] );
refresh_surflist();}
              xywh {0 0 30 20}
            }
          }
        }
        Fl_Group vectorgrp {
          label Vectors
          xywh {15 325 315 155} color 75 labelfont 1 labelsize 12 labelcolor 146 hide deactivate
        } {
          Fl_Light_Button veconbut {
            label Vectors
            callback {mwtb->vecdata->display(o->value());
mwtb->redraw();}
            tooltip {display vectors?} xywh {20 340 70 25} value 1
          }
          Fl_Roller veclength {
            label {Scale Arrows}
            callback {mwtb->vecdata->length(o->value());
mwtb->redraw();}
            tooltip {scale all vectors} xywh {100 340 150 25} type Horizontal labelsize 12 align 8 maximum 100 step 0.1 value 1
          }
          Fl_Button veccolor {
            label colour
            callback {mwtb->vecdata->colourize();
mwtb->redraw();}
            tooltip {fixed colour} xywh {255 375 75 25}
          }
          Fl_Light_Button vecautocal {
            label {auto cs}
            callback {mwtb->vecdata->auto_cs(o->value());}
            tooltip {calibrate every new time} xywh {20 410 80 30}
          }
          Fl_Choice veccstype {
            label {colour scale}
            xywh {220 410 110 30} down_box BORDER_BOX labelsize 10 align 2
            code0 {\#include "Colourscale.h"}
            code1 {o->value(1);}
          } {
            MenuItem {} {
              callback {mwtb->vecdata->cs->scale(CS_RAINBOW);
mwtb->redraw();}
              image {rainbow.xpm} xywh {15 15 100 20}
            }
            MenuItem {} {
              callback {mwtb->vecdata->cs->scale(CS_BL_RAINBOW);
mwtb->redraw();}
              image {blrainbow.xpm} xywh {15 15 100 20}
            }
            MenuItem {} {
              callback {mwtb->vecdata->cs->scale(CS_HOT);
mwtb->redraw();}
              image {hot.xpm} xywh {15 15 100 20}
            }
            MenuItem {} {
              callback {mwtb->vecdata->cs->scale(CS_COLD_HOT);
mwtb->redraw();}
              image {coldhot.xpm} xywh {15 15 100 20}
            }
            MenuItem {} {
              callback {mwtb->vecdata->cs->scale(CS_GREY);
mwtb->redraw();}
              image {blwhite.xpm} xywh {15 15 100 20}
            }
            MenuItem {} {
              callback {mwtb->vecdata->cs->scale(CS_CG);
mwtb->redraw();}
              image {cg.xpm} xywh {15 15 100 20}
            }
            MenuItem {} {
              callback {mwtb->vecdata->cs->scale(CS_MATLAB);
mwtb->redraw();}
              image {matlab.xpm} xywh {15 15 100 20}
            }
          }
          Fl_Menu_Button veclengthdeterm {
            label Length
            tooltip {determinant of vector length} xywh {20 375 90 25}
          } {
            MenuItem {} {
              label {Vector mag}
              callback {mwtb->vecdata->length_det(Vector);
mwtb->redraw();}
              xywh {5 5 100 20}
            }
            MenuItem {} {
              label Scalar
              callback {mwtb->vecdata->length_det(Scalar);
mwtb->redraw();}
              xywh {5 5 100 20}
            }
            MenuItem {} {
              label Fixed
              callback {mwtb->vecdata->length_det(FixedVCdata);
mwtb->redraw();}
              xywh {5 5 100 20}
            }
          }
          Fl_Menu_Button veccoldeterm {
            label Colour
            tooltip {determinant of vector colour} xywh {140 375 90 25}
          } {
            MenuItem {} {
              label {Vector mag}
              callback {mwtb->vecdata->colour_det(Vector);
mwtb->redraw();}
              xywh {15 15 100 20}
            }
            MenuItem {} {
              label Scalar
              callback {mwtb->vecdata->colour_det(Scalar);
mwtb->redraw();}
              xywh {15 15 100 20}
            }
            MenuItem {} {
              label Fixed
              callback {mwtb->vecdata->colour_det(FixedVCdata);
mwtb->redraw();}
              xywh {15 15 100 20}
            }
          }
          Fl_Button {} {
            label optimal
            callback {mwtb->vecdata->optimize_cs();
mwtb->redraw();}
            tooltip {calibrate for current time} xywh {120 410 75 30} box ROUND_UP_BOX labelsize 10
          }
          Fl_Value_Input vecstride {
            label {stride:}
            callback {mwtb->vecdata->stride(o->value());
mwtb->redraw();}
            xywh {65 451 35 24} when 8 minimum 1 maximum 100000 step 1 value 1
          }
        }
        Fl_Group auxgridgrp {
          label {Aux Grid} open
          xywh {15 305 320 180} box UP_BOX color 60 labelfont 1 labelsize 12 labelcolor 60 align 4 deactivate
        } {
          Fl_Light_Button auxgriddispbut {
            label On
            callback {mwtb->auxGrid->display( o->value() );
mwtb->redraw();}
            xywh {25 310 40 20} value 1 labelsize 10
          }
          Fl_Button {} {
            label optimal
            callback {mwtb->auxGrid->optimize_cs(tmslider->value());
auxmincolval->value(mwtb->auxGrid->cs.min());
auxmaxcolval->value(mwtb->auxGrid->cs.max());
mwtb->redraw();}
            tooltip {calibrate for current time} xywh {70 310 45 20} box ROUND_UP_BOX labelsize 10
          }
          Fl_Choice auxcstype {
            label {colour scale}
            xywh {195 345 90 20} down_box BORDER_BOX labelsize 10 align 2
            code0 {\#include "Colourscale.h"}
            code1 {o->value(1);}
          } {
            MenuItem {} {
              callback {mwtb->auxGrid->cs.scale(CS_RAINBOW);
mwtb->redraw();}
              image {rainbow.xpm} xywh {10 10 100 20}
            }
            MenuItem {} {
              callback {mwtb->auxGrid->cs.scale(CS_BL_RAINBOW);
mwtb->redraw();}
              image {blrainbow.xpm} xywh {10 10 100 20}
            }
            MenuItem {} {
              callback {mwtb->auxGrid->cs.scale(CS_HOT);
mwtb->redraw();}
              image {hot.xpm} xywh {10 10 100 20}
            }
            MenuItem {} {
              callback {mwtb->auxGrid->cs.scale(CS_COLD_HOT);
mwtb->redraw();}
              image {coldhot.xpm} xywh {10 10 100 20}
            }
            MenuItem {} {
              callback {mwtb->auxGrid->cs.scale(CS_GREY);
mwtb->redraw();}
              image {blwhite.xpm} xywh {10 10 100 20}
            }
            MenuItem {} {
              callback {mwtb->auxGrid->cs.scale(CS_CG);
mwtb->redraw();}
              image {cg.xpm} xywh {10 10 100 20}
            }
            MenuItem {} {
              callback {mwtb->auxGrid->cs.scale(CS_MATLAB);
mwtb->redraw();}
              image {matlab.xpm} xywh {10 10 100 20}
            }
          }
          Fl_Value_Input auxmincolval {
            label min
            callback {mwtb->auxGrid->cs.calibrate(o->value(),mwtb->auxGrid->cs.max());
mwtb->redraw();}
            xywh {20 345 65 20} labelsize 10 align 2 when 4 textsize 10
          }
          Fl_Value_Input auxmaxcolval {
            label max
            callback {mwtb->auxGrid->cs.calibrate(mwtb->auxGrid->cs.min(),o->value());
mwtb->redraw();}
            xywh {90 345 65 20} labelsize 10 align 2 when 4 textsize 10
          }
          Fl_Value_Input auxnumcolev {
            label levels
            callback {mwtb->auxGrid->cs.size((int)(o->value()));
mwtb->redraw();}
            tooltip {colourmap size} xywh {160 345 30 20} labelsize 10 align 2 when 4 minimum 4 maximum 252 step 1 value 64 textsize 12
          }
          Fl_Light_Button auxautocalibratebut {
            label auto
            callback {mwtb->auxGrid->autocolor(o->value());}
            tooltip {autoscale every timestep} xywh {290 345 40 20} labelsize 10 align 16
          }
          Fl_Group {} {
            label Vertex open
            xywh {65 375 255 30} labelsize 12 align 4
          } {
            Fl_Button auxptcolor {
              label color
              callback {AuxColourChoice *cc=new AuxColourChoice(mwtb->auxGrid->color(Vertex),Vertex,mwtb);
mwtb->redraw();}
              xywh {65 380 55 20}
            }
            Fl_Light_Button auxptdat {
              label data
              callback {mwtb->auxGrid->datify(Vertex,o->value());
mwtb->redraw();}
              xywh {125 380 50 20}
            }
            Fl_Value_Input auxptsize {
              label {size:}
              callback {mwtb->auxGrid->size(Vertex,o->value());
mwtb->redraw();}
              xywh {205 380 55 20} labelsize 12 maximum 1e+06 step 5 value 50
            }
            Fl_Choice auxptstyle {
              xywh {260 380 50 20} down_box BORDER_BOX labelsize 10 align 8
              code0 {o->value(2);}
            } {
              MenuItem {} {
                label Off
                callback {mwtb->auxGrid->showobj(Vertex,false);
mwtb->redraw();}
                xywh {10 10 31 20}
              }
              MenuItem {} {
                label Point
                callback {mwtb->auxGrid->showobj(Vertex,true);
mwtb->auxGrid->threeD(Vertex,false);
mwtb->redraw();}
                xywh {10 10 31 20}
              }
              MenuItem {} {
                label 3D
                callback {mwtb->auxGrid->showobj(Vertex,true);
mwtb->auxGrid->threeD(Vertex,true);
mwtb->redraw();}
                xywh {10 10 31 20}
              }
            }
          }
          Fl_Group {} {
            label Lines
            xywh {65 405 255 25} labelsize 12 align 4
          } {
            Fl_Button auxlinecolor {
              label color
              callback {AuxColourChoice *cc=new AuxColourChoice(mwtb->auxGrid->color(Cnnx),Cnnx,mwtb);
mwtb->redraw();}
              xywh {65 405 55 20}
            }
            Fl_Light_Button auxlinedat {
              label data
              callback {mwtb->auxGrid->datify(Cnnx,o->value());
mwtb->redraw();}
              xywh {125 405 50 20}
            }
            Fl_Value_Input auxlinewidth {
              label {size:}
              callback {mwtb->auxGrid->size(Cnnx,o->value());
mwtb->redraw();}
              xywh {205 405 55 20} labelsize 12 maximum 10000 step 5 value 100
            }
            Fl_Choice auxlinestyle {open
              xywh {260 405 50 20} down_box BORDER_BOX labelsize 12 align 8
              code0 {o->value(2);}
            } {
              MenuItem {} {
                label Off
                callback {mwtb->auxGrid->showobj(Cnnx,false);
mwtb->redraw();}
                xywh {15 15 31 20}
              }
              MenuItem {} {
                label Line
                callback {mwtb->auxGrid->showobj(Cnnx,true);
mwtb->auxGrid->threeD(Cnnx,false);
mwtb->redraw();}
                xywh {15 15 31 20}
              }
              MenuItem {} {
                label 3D
                callback {mwtb->auxGrid->showobj(Cnnx,true);
mwtb->auxGrid->threeD(Cnnx,true);
mwtb->redraw();}
                xywh {15 15 31 20}
              }
            }
          }
          Fl_Group {} {
            label Surface
            xywh {65 430 265 20} labelsize 12 align 4
          } {
            Fl_Button auxsurfcolor {
              label color
              callback {AuxColourChoice *cc=new AuxColourChoice(mwtb->auxGrid->color(SurfEle),SurfEle,mwtb);
mwtb->redraw();}
              xywh {65 430 55 20}
            }
            Fl_Light_Button auxsurfdat {
              label data
              callback {mwtb->auxGrid->datify(Surface,o->value());
mwtb->redraw();}
              xywh {125 430 50 20}
            }
            Fl_Value_Input auxsurfline {
              label {size:}
              callback {mwtb->auxGrid->size(SurfEle,o->value());
mwtb->redraw();}
              xywh {205 430 55 20} labelsize 12 maximum 100000 step 5 value 10
            }
            Fl_Choice auxsurfstyle {open
              xywh {260 430 50 20} down_box BORDER_BOX align 8
              code0 {o->value(2);}
            } {
              MenuItem {} {
                label Off
                callback {mwtb->auxGrid->showobj(SurfEle,false);
mwtb->redraw();}
                xywh {10 10 31 20}
              }
              MenuItem {} {
                label Outline
                callback {mwtb->auxGrid->showobj(SurfEle,true);
mwtb->auxGrid->surfill(false);
mwtb->redraw();}
                xywh {10 10 31 20}
              }
              MenuItem {} {
                label Filled
                callback {mwtb->auxGrid->showobj(SurfEle,true);
mwtb->auxGrid->surfill(true);
mwtb->redraw();}
                xywh {10 10 31 20}
              }
            }
          }
          Fl_Group {} {
            label VoxEle
            xywh {65 454 245 22} labelsize 12 align 4
          } {
            Fl_Button auxvolcolor {
              label color
              callback {AuxColourChoice *cc=new AuxColourChoice(mwtb->auxGrid->color(VolEle),VolEle,mwtb);
mwtb->redraw();}
              xywh {65 455 55 20}
            }
            Fl_Light_Button auxvoldat {
              label data
              callback {mwtb->auxGrid->datify(VolEle,o->value());
mwtb->redraw();}
              xywh {125 455 50 20}
            }
            Fl_Value_Input auxvolline {
              label {size:}
              callback {mwtb->auxGrid->size(VolEle,o->value());
mwtb->redraw();}
              xywh {205 455 55 20} labelsize 12 maximum 10000 step 5 value 10
            }
            Fl_Choice auxvolstyle {open
              xywh {260 455 50 20} down_box BORDER_BOX align 8
              code0 {o->value(2);}
            } {
              MenuItem {} {
                label Off
                callback {mwtb->auxGrid->showobj(VolEle,false);
mwtb->redraw();}
                xywh {15 15 31 20}
              }
              MenuItem {} {
                label Outline
                callback {mwtb->auxGrid->showobj(VolEle,true);
mwtb->auxGrid->volfill(false);
mwtb->redraw();}
                xywh {15 15 31 20}
              }
              MenuItem {} {
                label Filled
                callback {mwtb->auxGrid->showobj(VolEle,true);
mwtb->auxGrid->volfill(true);
mwtb->redraw();}
                xywh {15 15 31 20}
              }
            }
          }
          Fl_Button plotAuxTS {
            label Plot
            callback {mwtb->auxGrid->plot(tmslider->value());}
            tooltip {show time series for highlighted point} xywh {305 310 25 20} labelsize 10 deactivate
          }
          Fl_Light_Button hiAuxVert {
            label Hi
            callback {mwtb->auxGrid->highlight(o->value());
if( o->value() ) {
  auxhivert->activate();
  if( mwtb->auxGrid->data() ) {
   auxvertval->activate();
   if( mwtb->auxGrid->plottable() )
     plotAuxTS->activate();
  }  
  float val;
  if(mwtb->auxGrid->highlight_vertex(auxhivert->value(),val) )
    auxvertval->value(val);
} else {
  auxhivert->deactivate();
  auxvertval->deactivate();
  plotAuxTS->deactivate();
}
mwtb->redraw();}
            tooltip {turn on highlighting} xywh {270 310 30 20} labelsize 10
          }
          Fl_Value_Input auxhivert {
            label Hilight
            callback {float val;
if( mwtb->auxGrid->highlight_vertex(o->value(),val) )
  auxvertval->value(val);
mwtb->redraw();}
            tooltip {vertex to highlight and display time series if present} xywh {125 310 45 19} labelsize 10 align 2 step 1 textsize 10 deactivate
            code0 {\#include "MyValueInput.h"}
            class MyValueInput
          }
          Fl_Value_Output auxvertval {
            label {hi value:}
            tooltip {value of highlighted vertex} xywh {180 311 85 18} color 17 selection_color 0 labelsize 10 align 2 textsize 10
          }
        }
      }
      Fl_Group colorscalegrp {
        xywh {10 490 330 60} box ENGRAVED_BOX
      } {
        Fl_Button {} {
          label optimal
          callback {mwtb->optimize_cs();
mincolval->value(mwtb->cs->min());
maxcolval->value(mwtb->cs->max());}
          tooltip {calibrate for current time} xywh {15 495 45 20} box ROUND_UP_BOX labelsize 10
        }
        Fl_Choice cstype {
          label {colour scale}
          xywh {230 500 105 25} down_box BORDER_BOX labelsize 10 align 2
          code0 {\#include "Colourscale.h"}
          code1 {o->value(1);}
        } {
          MenuItem {} {
            callback {mwtb->cs->scale(CS_RAINBOW);
mwtb->redraw();}
            image {rainbow.xpm} xywh {0 0 100 20}
          }
          MenuItem {} {
            callback {mwtb->cs->scale(CS_BL_RAINBOW);
mwtb->redraw();}
            image {blrainbow.xpm} xywh {0 0 100 20}
          }
          MenuItem {} {
            callback {mwtb->cs->scale(CS_HOT);
mwtb->redraw();}
            image {hot.xpm} xywh {0 0 100 20}
          }
          MenuItem {} {
            callback {mwtb->cs->scale(CS_COLD_HOT);
mwtb->redraw();}
            image {coldhot.xpm} xywh {0 0 100 20}
          }
          MenuItem {} {
            callback {mwtb->cs->scale(CS_GREY);
mwtb->redraw();}
            image {blwhite.xpm} xywh {0 0 100 20}
          }
          MenuItem {} {
            callback {mwtb->cs->scale(CS_CG);
mwtb->redraw();}
            image {cg.xpm} xywh {0 0 100 20}
          }
          MenuItem {} {
            callback {mwtb->cs->scale(CS_MATLAB);
mwtb->redraw();}
            image {matlab.xpm} xywh {0 0 100 20}
          }
        }
        Fl_Value_Input mincolval {
          label min
          callback {mwtb->cs->calibrate(o->value(),mwtb->cs->max());
mwtb->redraw();}
          xywh {65 500 65 25} labelsize 10 align 2 when 4 textsize 12
        }
        Fl_Value_Input maxcolval {
          label max
          callback {mwtb->cs->calibrate(mwtb->cs->min(),o->value());
mwtb->redraw();}
          xywh {130 500 65 25} labelsize 10 align 2 when 4 textsize 12
        }
        Fl_Value_Input numcolev {
          label levels
          callback {mwtb->cs->size((int)(o->value()));
mwtb->redraw();}
          tooltip {colourmap size} xywh {195 500 30 25} labelsize 10 align 2 when 4 minimum 4 maximum 252 step 1 value 64 textsize 12
        }
        Fl_Light_Button autocalibratebut {
          label auto
          callback {mwtb->autocolour(o->value());}
          tooltip {autoscale every timestep} xywh {15 520 45 15} labelsize 10 align 16
        }
      }
      Fl_Group animate_group {open
        xywh {10 555 330 85} box ENGRAVED_BOX
      } {
        Fl_Box tmslider {
          label time
          callback {mwtb->set_time(int(o->value()));}
          tooltip {time displayed} xywh {15 570 220 25} align 1
          code0 {\#include "Myslider.h"}
          class Myslider
        }
        Fl_Button {} {
          label {@>>}
          callback {mwtb->animate_skip( int(frameskip->value()),this );}
          tooltip {start animation} xywh {245 560 25 35} labelcolor 71
        }
        Fl_Button {} {
          label {@||}
          callback {mwtb->animate_skip(0,this);}
          tooltip {stop animation} xywh {275 560 25 35} labelcolor 1
        }
        Fl_Counter frameskip {
          label {\#frames}
          callback {mwtb->animate_skip(int(frameskip->value()),NULL);}
          tooltip {\#frames to  increment} xywh {75 605 130 20} align 4 step 1 value 1
        }
        Fl_Value_Input animdelay {
          label {delay:}
          callback {mwtb->animate_delay(o->value()/1000.);}
          tooltip {delay between frames (ms )} xywh {260 620 70 20} maximum 2000 step 5 value 10
        }
        Fl_Button tsync_but {
          callback {mwtb->SendTimeSyncMessage();}
          image {sync-icon.png} xywh {305 560 25 35} resizable
        }
      }
    }
  }
  Function {outputwin( TBmeshWin *w )} {return_type void
  } {
    code {mwtb = w;} {}
  }
  decl {TBmeshWin *mwtb;} {private local
  }
  decl {Fl_Window* proginfo;} {public local
  }
  Function {pickcolor(Object_t obj, const char* wintitle )} {open
  } {
    code {bool* sel=regselected();
for( int i=0; i<reglist->nitems(); i++ )
  if( sel[i] ) { 
   GLfloat *c = mwtb->get_color(obj, i);
   colourChoice *cc = new colourChoice( c, sel, reglist->nitems(), obj, mwtb );
   cc->window->label(wintitle);
   cc->window->show();
   break;
   }
delete[] sel;} {}
  }
  Function {update_surfGUI( int s )} {return_type void
  } {
    code {if( !mwtb->model->numSurf() ) return;
surfvisbut->value( mwtb->model->surface(s)->visible() );
surfoutlinebut->value( mwtb->model->surface(s)->outline() );
surffillbut->value( mwtb->model->surface(s)->filled() );} {}
  }
  Function {update_regionGUI( int r )} {return_type void
  } {
    code {visbut->value( mwtb->visibility(r) );
vertbut->value( mwtb->showobj(Vertex, r) );
cabbut->value( mwtb->showobj(Cable, r) );
cnnxbut->value( mwtb->showobj(Cnnx, r) );} {}
  }
  Function {highlight_region()} {} {
    code {int regnum;
for( regnum=0; regnum<reglist->nitems(); regnum++ )
  if( reglist->checked(regnum) )
    break;
regnum--;

int objnum = mwtb->reg_first( regnum, VolEle );
mwtb->highlight( VolEle, objnum );
tethi->value( objnum );
objnum = mwtb->reg_first(regnum, Cnnx );
mwtb->highlight( Cnnx, objnum );
cnnxhi->value( objnum );
objnum = mwtb->reg_first( regnum, Cable );
mwtb->highlight( Cable, objnum );
cabhi->value( objnum );
objnum =0;
for( int i=0; i<regnum; i++ ) objnum += mwtb->model->surface(i)->num();
mwtb->highlight( SurfEle, objnum );
elehi->value( objnum );
objnum = mwtb->reg_first( regnum, Vertex );
mwtb->highlight( Vertex, objnum );
verthi->value( objnum );} {}
  }
  Function {set_rot( char n, int neg, int view )} {return_type void
  } {
    code {V3f xaxis(1,0,0);
V3f yaxis(0,1,0);
V3f zaxis(0,0,1);

if( n == 'X' ) {
  mwtb->trackball.SetRotation(-M_PI_2*(1-2*neg),yaxis);
  if( !neg )mwtb->trackball.Rotation(-M_PI_2,zaxis);
} else if( n == 'Y' ) { 
  mwtb->trackball.SetRotation(M_PI_2*(1-2*neg),xaxis);
  if( !neg )mwtb->trackball.Rotation(M_PI_2,zaxis);
} else {
  mwtb->trackball.SetRotation(M_PI*neg,yaxis);
  if( neg )mwtb->trackball.Rotation(-M_PI_2,zaxis);
}
mwtb->trackball.Rotation(-view*M_PI_2,zaxis);

mwtb->redraw();} {}
  }
  Function {set_tet_region( Model *model)} {open
  } {
    code {for( int i=0; i<model->_numReg; i++ ) {
  char text[256];
  sprintf( text, "%d", (model->region(i))->label() );
  reglist->add( text, 0 );
  reglist->checked(i+1,1);
}} {selected
    }
  }
  Function {regselected()} {return_type {bool *}
  } {
    code {bool *sel = new bool[reglist->nitems()];
for( int i=1; i<=reglist->nitems(); i++ )
  sel[i-1] = reglist->checked(i);
return sel;} {}
  }
  Function {save_state()} {open
  } {
    code {char *fn = fl_file_chooser("meshalyzer state file","*.mshz",NULL);
if( fn==NULL) return;
string xfn( fn );
if( xfn.rfind(".mshz") == string::npos ) xfn += ".mshz";
ofstream mshzf( xfn.c_str() );

mshzf << "TRACKBALL ======" << endl;
mwtb->trackball.save(mshzf);
mshzf << "CLIPPING ======" << endl;
mwtb->cplane->save(mshzf);
mshzf << "DATA_OPACITY ======" << endl;
mwtb->dataopac->save(mshzf);

SAVE_WIDGET(mshzf,read_recalibrate);
SAVE_WIDGET(mshzf,revdraworder);
SAVE_WIDGET(mshzf,datachc);
SAVE_WIDGET(mshzf,draw_axes);
//region group
SAVE_WIDGET(mshzf,vertbut);
SAVE_WIDGET(mshzf,cabbut);
SAVE_WIDGET(mshzf,cnnxbut);
//hilighttab
SAVE_WIDGET(mshzf,hilighton);
SAVE_WIDGET(mshzf,hitettype);
SAVE_WIDGET(mshzf,tethi);
SAVE_WIDGET(mshzf,elehi);
SAVE_WIDGET(mshzf,verthi);
SAVE_WIDGET(mshzf,cnnxhi);
SAVE_WIDGET(mshzf,verthi);
SAVE_WIDGET(mshzf,cabhi);
SAVE_WIDGET(mshzf,attachtype);
//vector tab
SAVE_WIDGET(mshzf,veconbut);
SAVE_WIDGET(mshzf,veccstype);
SAVE_WIDGET(mshzf,veclength);
SAVE_WIDGET(mshzf,vecautocal);
//light tab
SAVE_WIDGET(mshzf,lightx);
SAVE_WIDGET(mshzf,lighty);
SAVE_WIDGET(mshzf,lightz);
SAVE_WIDGET(mshzf,ambientslide);
SAVE_WIDGET(mshzf,specularslide);
SAVE_WIDGET(mshzf,diffuseslide);
SAVE_WIDGET(mshzf,backintensityslide);
SAVE_WIDGET(mshzf,showLightDir);
SAVE_WIDGET(mshzf,facetshadBut);
SAVE_WIDGET(mshzf,illBut);
//surface tab
SAVE_WIDGET(mshzf,surfvisbut);
SAVE_WIDGET(mshzf,surfoutlinebut);
SAVE_WIDGET(mshzf,surffillbut);
// Aux Grid tab
SAVE_WIDGET(mshzf,auxgriddispbut);
SAVE_WIDGET(mshzf,auxcstype);
SAVE_WIDGET(mshzf,auxmincolval);
SAVE_WIDGET(mshzf,auxmaxcolval);
SAVE_WIDGET(mshzf,auxnumcolev);
SAVE_WIDGET(mshzf,auxautocalibratebut);
SAVE_WIDGET(mshzf,auxptdat);
SAVE_WIDGET(mshzf,auxptsize);
SAVE_WIDGET(mshzf,auxptstyle);
SAVE_WIDGET(mshzf,auxlinedat);
SAVE_WIDGET(mshzf,auxlinewidth);
SAVE_WIDGET(mshzf,auxlinestyle);
SAVE_WIDGET(mshzf,auxsurfdat);
SAVE_WIDGET(mshzf,auxsurfline);
SAVE_WIDGET(mshzf,auxsurfstyle);
SAVE_WIDGET(mshzf,auxvoldat);
SAVE_WIDGET(mshzf,auxvolline);
SAVE_WIDGET(mshzf,auxvolstyle);
if(mwtb->auxGrid){
  mshzf << "AUX_GRID_COLOURS = 4" << endl;
  save_colour(mshzf, mwtb->auxGrid->color(Vertex) );
  mshzf << " ";
  save_colour(mshzf, mwtb->auxGrid->color(Cnnx) );
  mshzf << " ";
  save_colour(mshzf, mwtb->auxGrid->color(SurfEle) );
  mshzf << " ";
  save_colour(mshzf, mwtb->auxGrid->color(VolEle) );
  mshzf << endl;
}
// colour scale
SAVE_WIDGET(mshzf,autocalibratebut);
SAVE_WIDGET(mshzf,mincolval);
SAVE_WIDGET(mshzf,maxcolval);
SAVE_WIDGET(mshzf,numcolev);
SAVE_WIDGET(mshzf,cstype);
// animation
SAVE_WIDGET(mshzf,tmslider);
SAVE_WIDGET(mshzf,frameskip);
SAVE_WIDGET(mshzf,animdelay);


mshzf << "SURFACE_COLOURS = " << mwtb->model->numSurf() << endl;
for( int i=0; i<mwtb->model->numSurf(); i++ ) {
  save_colour( mshzf, mwtb->model->surface(i)->fillcolor() );
  mshzf << " ";
  save_colour( mshzf, mwtb->model->surface(i)->outlinecolor() );
  mshzf << " " << mwtb->model->surface(i)->visible();
  mshzf << " " << mwtb->model->surface(i)->filled();
  mshzf << " " << mwtb->model->surface(i)->outline();
  mshzf << endl;
}

mshzf << "REGION_SIZE = " << mwtb->model->_numReg << endl;
for( int i=0; i<mwtb->model->_numReg; i++ ) {
  RRegion *r =  mwtb->model->region(i);
  mshzf << r->size(Vertex) << " ";
  mshzf << r->size(Cable) << " ";
  mshzf << r->size(Cnnx) << endl;
}

mshzf << "stride =";
mshzf << " " << mwtb->stride(Vertex);
mshzf << " " << mwtb->stride(Cable);
mshzf << " " << mwtb->stride(Cnnx) << endl;

mshzf << "REGION_3D = " << mwtb->model->_numReg << endl;
for( int i=0; i<mwtb->model->_numReg; i++ ) {
  RRegion *r =  mwtb->model->region(i);
  mshzf << r->threeD(Vertex) << " ";
  mshzf << r->threeD(Cable) << " ";
  mshzf << r->threeD(Cnnx) << endl;
}

mshzf << "REGION_COLOURS = " << mwtb->model->_numReg << endl;
for( int i=0; i<mwtb->model->_numReg; i++ ) {
  save_colour( mshzf, mwtb->model->region(i)->get_color(Vertex) );
  mshzf << " " << mwtb->model->region(i)->show(Vertex) << " ";
  save_colour( mshzf, mwtb->model->region(i)->get_color(Cable) );
  mshzf << " " << mwtb->model->region(i)->show(Cable) << " ";
  save_colour( mshzf, mwtb->model->region(i)->get_color(Cnnx) );
  mshzf << " " << mwtb->model->region(i)->show(Cnnx) << " " 
        << mwtb->model->region(i)->visible() << endl; 
}
mshzf << "BGD_COLOUR = " << (mwtb->bgd())[1] << endl;

mshzf << "ISOLINE_COLOUR = ";
save_colour( mshzf, mwtb->isosurfwin ->islColor() );
mshzf << endl;
SAVE_WIDGET( mshzf, mwtb->isosurfwin->isolineVal0 );
SAVE_WIDGET( mshzf, mwtb->isosurfwin->isolineVal1 );
SAVE_WIDGET( mshzf, mwtb->isosurfwin->isoNumLines );
SAVE_WIDGET( mshzf, mwtb->isosurfwin->isolineThick );
SAVE_WIDGET( mshzf, mwtb->isosurfwin->islDatify );
SAVE_WIDGET( mshzf, mwtb->isosurfwin->isolineOn );
SAVE_WIDGET( mshzf, mwtb->isosurfwin->isoOn0 );
SAVE_WIDGET( mshzf, mwtb->isosurfwin->isoval0 );
SAVE_WIDGET( mshzf, mwtb->isosurfwin->opacity0 );
mshzf << "ISOSURF_COLOUR 0 = ";
save_colour( mshzf, mwtb->isosurfwin->issColor(0) );
mshzf << endl;} {}
  }
  Function {save_colour( ofstream&ofs, const GLfloat *col )} {open
  } {
    code {for( int c=0; c<3; c++ ) ofs << col[c] << " ";
ofs << col[3];} {}
  }
  Function {pick_surf_color(Object_t ot, const char *winlab)} {} {
    code {int msz = surflist->nitems();

if( !msz ) return;

bool* cs = new bool[msz];
GLfloat *col;

for( int mi=0; mi<surflist->nitems(); mi++ ) 
 if( surflist->checked(mi+1) ){
   cs[mi] = true;
   col = mwtb->get_color(ot, mi);
 } else
   cs[mi] = false;  

colourChoice *cc = new colourChoice( col, cs, msz, ot, mwtb );
cc->window->label(winlab);
cc->window->show();} {}
  }
  Function {restore_state(const char* fname=NULL)} {open
  } {
    code {ifstream mshzf;
if( fname==NULL ) {
  char *fn=fl_file_chooser("Meshalyzer state file", "*.mshz", NULL );
  if( fn==NULL) return;
  mshzf.open(fn);
} else
  mshzf.open(fname);

int BUFLEN=1024;
char buf[BUFLEN];
float r, g, b, a;

while( mshzf.getline( buf, BUFLEN ) ) {
  
  float val;
  char  var[1024];
  if( sscanf( buf, "%s = %f", var, &val ) <1 )
    continue;
  if( !strcmp( var, "TRACKBALL" ) ) {
	mwtb->trackball.read(mshzf); 
	continue;
  } 
  if( !strcmp( var, "DATA_OPACITY" ))  {
	mwtb->dataopac->read(mshzf); 
	continue;
  } 
  if( !strcmp( var, "CLIPPING" ))  {
	mwtb->cplane->read(mshzf); 
	continue;
  } 
  if( !strcmp( var, "SURFACE_COLOURS" ) ) {
    for( int i=0; i<val; i++ ) {
      if( i >= mwtb->model->numSurf() ){
        mshzf.getline(var, 1024);
        continue;
      }
      mshzf >> r >> g >> b >> a;
      mwtb->model->surface(i)->fillcolor(r,g,b,a);
      mshzf >> r >> g >> b >> a;
      mwtb->model->surface(i)->outlinecolor(r,g,b,a);
      mshzf >> r >> g >> b;
      mwtb->model->surface(i)->visible(int(r));
      mwtb->model->surface(i)->filled(int(g));
      mwtb->model->surface(i)->outline(int(b));
	}
	continue;
  } 
  if( !strcmp( var, "REGION_COLOURS" ) ) {
    bool  v;
    for( int i=0; i<val; i++ ) {
      if( i >= mwtb->model->_numReg ) {
         mshzf.getline( buf, BUFLEN );
         continue;
      }     
      mshzf >> r >> g >> b >> a >> v;
      mwtb->model->region(i)->set_color(Vertex, r, g, b, a );
      mwtb->model->region(i)->show( Vertex, v );
      mshzf >> r >> g >> b >> a >> v;
      mwtb->model->region(i)->set_color(Cable, r, g, b, a );   
      mwtb->model->region(i)->show( Cable, v );
      mshzf >> r >> g >> b >> a >> v;
      mwtb->model->region(i)->set_color(Cnnx, r, g, b, a ); 
      mwtb->model->region(i)->show( Cnnx, v );
      mshzf >> v;
      mwtb->model->region(i)->visible(v);
      mshzf.getline( buf, BUFLEN );
    }
	continue;
  }
  if( !strcmp( var, "REGION_3D" ) ) {
    bool  v;
    for( int i=0; i<val; i++ ) {
      if( i >= mwtb->model->_numReg ) {
         mshzf.getline( buf, BUFLEN );
         continue;
      }     
      mshzf >> v;
      mwtb->model->region(i)->threeD( Vertex, v );
      mshzf >> v;
      mwtb->model->region(i)->threeD( Cable, v );
      mshzf >> v;
      mwtb->model->region(i)->threeD( Cnnx, v );
      mshzf.getline( buf, BUFLEN );
    }
    continue;
  } 
  if( !strcmp( var, "REGION_SIZE" ) ) {
    for( int i=0; i<val; i++ ) {
      if( i >= mwtb->model->_numReg ) {
         mshzf.getline( buf, BUFLEN );
      } else {
        float s;
        mshzf >> s;
        mwtb->model->region(i)->size( Vertex, s );
        mshzf >> s;
        mwtb->model->region(i)->size( Cable, s );
        mshzf >> s;
        mwtb->model->region(i)->size( Cnnx, s );
        mshzf.getline( buf,BUFLEN );
      }
    }
   continue;
  } 
  if( !strcmp( var, "stride" ) ) {
    int vs, cbs, cxs;
    sscanf( buf, "%*s = %d %d %d", &vs, &cbs, &cxs );
    mwtb->stride( Vertex, vs );
    mwtb->stride( Cable, cbs );
    mwtb->stride( Cnnx, cxs );
    continue;
  } 
  TEST_MENUVAR( read_recalibrate, var, val )  
  TEST_MENUVAR( revdraworder, var, val )  
  TEST_CHOICE( datachc, var, int(val) )  
  TEST_VAR( draw_axes, var, int(val) )  
  TEST_VAR( vertbut, var, int(val) )  
  TEST_VAR( cabbut, var, int(val) )  
  TEST_VAR( cnnxbut, var, int(val) )    
  TEST_VAR( hilighton, var, int(val) ) 
  TEST_CHOICE( hitettype, var, int(val) ) 
  TEST_VAR( tethi, var, int(val) ) 
  TEST_VAR( elehi, var, int(val) ) 
  TEST_VAR( verthi, var, int(val) ) 
  TEST_VAR( cnnxhi, var, int(val) ) 
  TEST_VAR( cabhi, var, int(val) ) 
  TEST_CHOICE( attachtype, var, int(val) ) 
  if( mwtb->vecdata != NULL ) {
    TEST_CHOICE( veccstype, var, int(val) )
    TEST_VAR( veconbut, var, int(val) ) 
    TEST_VAR( veclength, var, val ) 
    TEST_VAR( vecautocal, var, int(val) ) 
  } else {
    IGNORE_VAR( veccstype, var )
    IGNORE_VAR( veconbut, var ) 
    IGNORE_VAR( veclength, var ) 
    IGNORE_VAR( vecautocal, var ) 
  }
  TEST_VAR( lightx, var, val ) 
  TEST_VAR( lighty, var, val ) 
  TEST_VAR( lightz, var, val ) 
  TEST_VAR( ambientslide, var, val ) 
  TEST_VAR( specularslide, var, val ) 
  TEST_VAR( diffuseslide, var, val ) 
  TEST_VAR( backintensityslide, var, val ) 
  TEST_VAR( showLightDir, var, int(val) ) 
  TEST_VAR( facetshadBut, var, int(val) ) 
  TEST_VAR( illBut, var, int(val) )  
  TEST_VAR( surfvisbut, var, int(val) ) 
  TEST_VAR( surfoutlinebut, var, int(val) ) 
  TEST_VAR( surffillbut, var, int(val) ) 
  TEST_VAR( autocalibratebut, var, int(val) ) 
  TEST_VAR( mincolval, var, val ) 
  TEST_VAR( maxcolval, var, val ) 
  TEST_VAR( numcolev, var, int(val) ) 
  TEST_CHOICE( cstype, var, int(val) ) 
  TEST_VAR( tmslider, var, int(val) ) 
  TEST_VAR( frameskip, var, int(val) ) 
  TEST_VAR( animdelay, var, int(val) ) 
  if( mwtb->auxGrid ) {
	TEST_VAR( auxgriddispbut, var, int(val) );
	TEST_CHOICE( auxcstype, var, int(val) );
	TEST_VAR( auxmincolval, var, val );
	TEST_VAR( auxmaxcolval, var, val );
	TEST_VAR( auxnumcolev, var, int(val) );
	TEST_VAR( auxautocalibratebut, var, int(val) );
	TEST_VAR( auxptdat, var, int(val) );
	TEST_VAR( auxptsize, var, val );
	TEST_CHOICE( auxptstyle, var, int(val) );
	TEST_VAR( auxlinedat, var, int(val) );
	TEST_VAR( auxlinewidth, var, val );
	TEST_CHOICE( auxlinestyle, var, int(val) );
	TEST_VAR( auxsurfdat, var, int(val) );
	TEST_VAR( auxsurfline, var, val );
	TEST_CHOICE( auxsurfstyle, var, int(val) ); 
	TEST_VAR( auxvoldat, var, int(val) );
	TEST_VAR( auxvolline, var, val );
	TEST_CHOICE( auxvolstyle, var, int(val) ); 
  } else {
	IGNORE_VAR( auxgriddispbut, var );
	IGNORE_VAR( auxcstype, var );
	IGNORE_VAR( auxmincolval, var );
	IGNORE_VAR( auxmaxcolval, var );
	IGNORE_VAR( auxnumcolev, var );
	IGNORE_VAR( auxautocalibratebut, var );
	IGNORE_VAR( auxptdat, var );
	IGNORE_VAR( auxptsize, var );
	IGNORE_VAR( auxptstyle, var );
	IGNORE_VAR( auxlinedat, var );
	IGNORE_VAR( auxlinewidth, var );
	IGNORE_VAR( auxlinestyle, var );
	IGNORE_VAR( auxsurfdat, var );
	IGNORE_VAR( auxsurfline, var );
	IGNORE_VAR( auxsurfstyle, var );
	IGNORE_VAR( auxvoldat, var );
	IGNORE_VAR( auxvolline, var );
	IGNORE_VAR( auxvolstyle, var );
  }
  if( !strcmp( var, "AUX_GRID_COLOURS" ) ) {
    if( mwtb->auxGrid ) {
      mshzf.getline( var, 1024 );
      float c[4];
      int nread;
      sscanf( var, "%f %f %f %f%n", c, c+1, c+2, c+3, &nread );
      mwtb->auxGrid->color( Vertex, c );
      sscanf( var+nread, "%f %f %f %f%n", c, c+1, c+2, c+3, &nread );
      mwtb->auxGrid->color( Cnnx, c );
      sscanf( var+nread, "%f %f %f %f%n", c, c+1, c+2, c+3, &nread );
      mwtb->auxGrid->color( SurfEle, c );
      sscanf( var+nread, "%f %f %f %f%n", c, c+1, c+2, c+3, &nread );
      mwtb->auxGrid->color( VolEle, c );
      continue;
    } else {
	  for( int i=0; i<4; i++ ) mshzf.getline( var, 1024 );
	}
  }
  TEST_VAR( mwtb->isosurfwin->isolineVal0, var, val )
  TEST_VAR( mwtb->isosurfwin->isolineVal1, var, val )
  TEST_VAR( mwtb->isosurfwin->isoNumLines, var, int(val) )
  TEST_VAR( mwtb->isosurfwin->isolineThick, var, int(val) )
  TEST_VAR( mwtb->isosurfwin->islDatify, var, int(val) )
  TEST_VAR( mwtb->isosurfwin->isolineOn, var, int(val) )
  TEST_VAR( mwtb->isosurfwin->isoval0, var, val )
  TEST_VAR( mwtb->isosurfwin->opacity0, var, val )
  TEST_VAR( mwtb->isosurfwin->isoOn0, var, val )
  if( !strcmp( var, "ISOLINE_COLOUR" ) ){
    sscanf( buf, "%*s = %f %f %f %f", &r, &g, &b, &a );
    mwtb->isosurfwin->islColor(r,g,b,a);
    continue;
  }
  if( !strcmp( var, "ISOSURF_COLOUR" ) ){
    sscanf( buf, "%*s %*d = %f %f %f %f", &r, &g, &b, &a );
    mwtb->isosurfwin->issColor(int(val),r,g,b,a);
    continue;
  }
  
  if( !strcmp( "BGD_COLOUR", var )) { mwtb->bgd(val); continue; }

  cerr << "Unknown variable specified: " << var << endl;
}
mwtb->lights(illBut->value());} {}
  }
  Function {surfselected(vector<int>& lst)} {} {
    code {lst.clear();
for( int i=1; i<=surflist->nitems(); i++ )
  if( surflist->checked(i) )
    lst.push_back(i-1);} {}
  }
  Function {refresh_surflist()} {} {
    code {surflist->clear(); 
for( int s=0; s<mwtb->model->numSurf(); s++ ) {
    surflist->add(mwtb->model->surface(s)->label().c_str(),1);
  }
  elehi->maximum(mwtb->model->number(SurfEle)-1);
  mwtb->redraw();
  surflist->redraw();} {}
  }
} 

class ProgInfo {} {
  Function {ProgInfo()} {open
  } {
    Fl_Window proginfo {
      label {Progam Version} open
      xywh {1082 25 560 570} type Single color 7 hide
    } {
      Fl_Text_Display infotxt {
        image {meshlogo.jpg} xywh {5 140 550 430} box NO_BOX
      }
    }
  }
} 

class ObjProps {} {
  Function {ObjProps( TBmeshWin* wtb, Object_t o, int nr, bool *s):mwtb(wtb),obj(o),numreg(nr),sel(s)} {open
  } {
    Fl_Window win {open
      xywh {688 522 310 65} type Single hide
    } {
      Fl_Button color {
        label colour
        callback {for( int i=0; i<numreg; i++ )
  if( sel[i] ) { 
   GLfloat *c = mwtb->get_color(obj, i);
   colourChoice *cc = new colourChoice( c, sel, numreg, obj, mwtb );
   string lab( objnames[obj] );
   lab += " colour";
   cc->window->label(lab.c_str());
   cc->window->show();
   break;
   }}
        xywh {10 10 100 45}
      }
      Fl_Check_Button thrD {
        label 3D
        callback {for( int i=0; i<numreg; i++ )
  if( sel[i] )
    mwtb->threeD( obj, i, static_cast<bool>(thrD->value()) );}
        xywh {160 0 30 30} down_box DOWN_BOX align 4
      }
      Fl_Value_Input stride {
        label Stride
        callback {mwtb->stride( obj, int(stride->value()) );}
        xywh {155 31 30 24} value 1
      }
      Fl_Value_Input sizeinp {
        label {size:}
        callback {for( int i=0; i<numreg; i++ )
  if( sel[i] )
     mwtb->size(obj, i, float(o->value()) );}
        xywh {230 21 70 28} maximum 10000 step 0.1 value 1
      }
    }
    code {for( int i=0; i<numreg; i++ )
  if( sel[i] ) {
    thrD->value( mwtb->threeD( obj, i ) );
    stride->value( mwtb->stride( obj ) );
    sizeinp->value( mwtb->size( obj, i ) );
  }} {}
  }
  decl {TBmeshWin *mwtb;} {private local
  }
  decl {Object_t obj;} {private local
  }
  decl {int numreg;} {private local
  }
  decl {bool *sel;} {private local
  }
} 
