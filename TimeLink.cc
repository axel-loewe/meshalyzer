// generated by Fast Light User Interface Designer (fluid) version 1.0303

#include "TimeLink.h"
#include <sys/types.h>
#include <cstdlib>
#include <cstdio>
#include <unistd.h>
#include <iostream>
#include <sys/msg.h>
#include <sys/ipc.h>
#include <semaphore.h>
#include <signal.h>

void TimeLink::cb_link_i(Fl_Button*, void*) {
  link();
}
void TimeLink::cb_link(Fl_Button* o, void* v) {
  ((TimeLink*)(o->parent()->parent()->user_data()))->cb_link_i(o,v);
}

void TimeLink::cb_refresh_i(Fl_Button*, void*) {
  list_mesh_pids();
}
void TimeLink::cb_refresh(Fl_Button* o, void* v) {
  ((TimeLink*)(o->parent()->parent()->user_data()))->cb_refresh_i(o,v);
}

void TimeLink::cb_Unlink_i(Fl_Button*, void*) {
  unlink();
}
void TimeLink::cb_Unlink(Fl_Button* o, void* v) {
  ((TimeLink*)(o->parent()->parent()->user_data()))->cb_Unlink_i(o,v);
}

void TimeLink::cb_close_i(Fl_Button*, void*) {
  window->hide();
}
void TimeLink::cb_close(Fl_Button* o, void* v) {
  ((TimeLink*)(o->parent()->user_data()))->cb_close_i(o,v);
}

TimeLink::TimeLink( set<int>& lnks ):linkages_(lnks),msqId_(0),MSQ_KEY_PATH("/home") {
  { window = new Fl_Double_Window(290, 410, "TimeLink");
    window->box(FL_ENGRAVED_BOX);
    window->color((Fl_Color)27);
    window->user_data((void*)(this));
    { Fl_Group* o = new Fl_Group(10, 10, 270, 195);
      o->box(FL_GTK_UP_BOX);
      o->color((Fl_Color)14);
      o->align(Fl_Align(65));
      { meshList = new Fl_Browser(20, 25, 250, 105);
        meshList->type(3);
      } // Fl_Browser* meshList
      { Fl_Button* o = new Fl_Button(55, 140, 170, 25, "link selected");
        o->color((Fl_Color)6);
        o->callback((Fl_Callback*)cb_link);
      } // Fl_Button* o
      { Fl_Button* o = new Fl_Button(55, 170, 170, 25, "refresh");
        o->color((Fl_Color)19);
        o->callback((Fl_Callback*)cb_refresh);
      } // Fl_Button* o
      o->end();
    } // Fl_Group* o
    { Fl_Group* o = new Fl_Group(10, 215, 270, 155);
      o->box(FL_GTK_UP_BOX);
      o->color((Fl_Color)10);
      { linkList = new Fl_Browser(15, 220, 250, 110);
        linkList->type(3);
        linkList->selection_color((Fl_Color)1);
      } // Fl_Browser* linkList
      { Fl_Button* o = new Fl_Button(55, 335, 170, 25, "Unlink selected");
        o->callback((Fl_Callback*)cb_Unlink);
      } // Fl_Button* o
      o->end();
    } // Fl_Group* o
    { Fl_Button* o = new Fl_Button(45, 375, 190, 25, "close");
      o->box(FL_GTK_UP_BOX);
      o->callback((Fl_Callback*)cb_close);
    } // Fl_Button* o
    window->end();
  } // Fl_Double_Window* window
  CreateMessageQueue();
}

/**
   list running meshalyzer PIDs which are not linked
*/
void TimeLink::list_mesh_pids() {
  const char *cmd = "ps -a -o pid,args | grep '[0-9]\\+ meshalyzer'";
  
  FILE *in = popen( cmd, "r" );
  
  meshList->clear();
  
  
  char procline[1024];
  
  while( fgets( procline, 1024, in ) != NULL ) {
    int pid = atoi( procline );
    if( getpid()!=pid && linkages_.find(pid)==linkages_.end() ) {
      meshList->add(procline);
    }
  }
  
  pclose( in );
}

/**
   Link the selected meshalyzer PIDs
*/
void TimeLink::link() {
  for( int i=1; i<=meshList->size(); i++ ){
      if( meshList->selected(i) ) {
  
        int pid = atoi(meshList->text(i));
  
        // link the message queue
        LinkMessageQueue(pid);
  
        // adding a new linkage to the list
        linkages_.insert(pid);
  
        // create a message queue communication with the process
        // put a message in the queue
        LinkMessage::CommandMsg msgToSend;
  	  strcpy(msgToSend.command, LinkMessage::LINK_COMMAND_LINK);
  
        SendMsg(msgToSend, pid);
        SignalNewMessageInQueue(pid);       
      }
    }
  
    list_links();
    list_mesh_pids();
}

void TimeLink::unlink() {
  for( int i=linkList->size(); i>=1; i-- ){
      if( linkList->selected(i) ) {
        int pid = atoi(linkList->text(i));
  
        // create a message queue communication with the process
        // put a message in the queue
        LinkMessage::CommandMsg msgToSend;
        strcpy(msgToSend.command, LinkMessage::LINK_COMMAND_UNLINK);
  
        SendMsg(msgToSend, pid);
        SignalNewMessageInQueue(pid); 
  
       // error the message queue
        linkageMsqIds_.erase(pid);
  
        // erase from linkage
        linkages_.erase(pid);
      }
    }
  
    list_links();
    list_mesh_pids();
}

void TimeLink::list_links() {
  linkList->clear();
  
  set<int>::iterator it;
  for ( it=linkages_.begin() ; it != linkages_.end(); it++ ){
    char pidtext[256];
    sprintf( pidtext, "%d", *it );
    linkList->add( pidtext );
  }
}

int TimeLink::LinkMessageQueue(int pid) {
  //1. create an unique key from pid
    int temp;
    key_t key;
    int retVal = 0;
    
    // todo: need to change the file.
    key = ftok(MSQ_KEY_PATH, pid);
    if (key == -1){
      perror("ftok");
      return -1;
    }
    
    temp = msgget(key, 0666 | IPC_CREAT);
  
    if (temp == -1) {
      perror("msgget");
      return -2;
    }
  
    // append the msg id to the data structure
    linkageMsqIds_[pid] = temp;
    return 0;
}

/**
   
    * \brief Temporal linking and message queue linking with a 
    *        meshalyzer \a pid
    *
    * \param[in] pid - link with a meshalyzer process
    *
    * \return int - 0 = SUCCESS, negative = fail
    *
    
*/
int TimeLink::link(int pid) {
  // check to see if the pid exist in the list of mesh pids
    list_mesh_pids();
  
    for(int i = 1; i <= meshList->size(); i++){
      int val = atoi(meshList->text(i));
      if (val == pid){
        // move to link list
        LinkMessageQueue(pid);
        linkages_.insert(pid);
      }
    }
  
    list_links();
    list_mesh_pids();
  
    return 0;
}

/**
    * \brief Unlink \a pid from an existing linkage 
    *
    * \param[in] pid - unlink this meshalyzer \a pid
    *
    * \return int - 0 = SUCCESS, negative = fail
*/
int TimeLink::unlink(int pid) {
  // look up the message queue id
    linkageMsqIds_.erase(pid);
  
    // erase from linkage
    linkages_.erase(pid);
  
    list_links();
    list_mesh_pids();
}

/**
    * \brief Create a new message queue for this process
    *
    * \return int - 0 = SUCCESS, negative = fail
*/
int TimeLink::CreateMessageQueue() {
  //1. create an unique key from pid
    int temp;
    key_t key;
    int retVal = 0;
    
    key = ftok(MSQ_KEY_PATH, getpid());
    if (key == -1){
      perror("ftok");
       return -1;
    }
    
    temp = msgget(key, 0666 | IPC_CREAT);
  
    if (temp == -1) {
      perror("msgget");
      return -2;
    }
  
    msqId_ = temp;
  
    return 0;
}

/**
    * \brief Delete an existing message queue with \a msqId
    *
    * \return int - 0 = SUCCESS, negative = fail
*/
int TimeLink::DeleteMessageQueue() {
  if (msgctl(msqId_, IPC_RMID, NULL) == -1) {
      perror("msgctl");
      return -1;
    }
    
    return 0;
}
extern sem_t *linkingProcSem;

/**
   * \brief Notify \a pid a new message in queue
    *
    * \param[in] pid - process id for a meshalyzer program
    *
    * \return int - 0 = SUCCESS, negative = fail
    *
*/
int TimeLink::SignalNewMessageInQueue(int pid) {
  // make sure we start at zero
    int numsem;
    sem_getvalue(linkingProcSem, &numsem);
    for (int i = 0; i < numsem; i++ ){
      sem_wait(linkingProcSem);
    }
  
    if (kill(pid, SIGALRM)){
      // an process doesn't exist anymore
      unlink(pid);    
    }
  
    sem_wait(linkingProcSem);
  
    return 0;
}

/**
   * \brief Notify \a pid a new message in queue
    *
    * \param[in] pid - process id for a meshalyzer program
    *
    * \return int - 0 = SUCCESS, negative = fail
*/
int TimeLink::SendMsg(LinkMessage::CommandMsg& msg, int pid) {
  int msqId = linkageMsqIds_[pid];
  
    if (msqId < 0){
      return -1;
    }
  
    int retVal = 0;
    msg.mtype = 1;
    msg.senderPid = getpid();
    msg.receiverPid = pid;
  
    int size = sizeof(struct LinkMessage::CommandMsg) -
      offsetof(struct  LinkMessage::CommandMsg, senderPid);
  
    retVal = msgsnd(msqId, (void *)&msg, size, IPC_NOWAIT);
    if (retVal == -1){
      return -1;
    }
}

/**
   * \brief Send msg to all linked processes
    *
    * \return int - 0 = SUCCESS, negative = fail
*/
void TimeLink::SendMsgToAll(LinkMessage::CommandMsg& msg) {
  set<int>::iterator it = linkages_.begin();
  
  for( it; it != linkages_.end(); it++) {
     SendMsg(msg, *it);
     SignalNewMessageInQueue(*it); 
  }
}

/**
   * \brief Receive a new message in queue
    *
    * \return int - 0 = SUCCESS, negative = fail
    *
*/
int TimeLink::ReceiveMsg(LinkMessage::CommandMsg& msg) {
  int size = sizeof(struct LinkMessage::CommandMsg) -
                 offsetof(struct LinkMessage::CommandMsg, senderPid);
  
  
    if (msgrcv(msqId_, (void *)&msg, size, 0, MSG_NOERROR | IPC_NOWAIT) == -1) {
      return -1;
    }
    return 0;
}

TimeLink::~TimeLink() {
  set<int>::iterator it = linkages_.begin();
    //unlink all
    for ( it; it != linkages_.end(); it++ ){
  
      int pid = *it; 
  
      // create a message queue communication with the process
      // put a message in the queue
      LinkMessage::CommandMsg msgToSend;
      strcpy(msgToSend.command, LinkMessage::LINK_COMMAND_UNLINK);
  	  
      SendMsg(msgToSend, pid);
      SignalNewMessageInQueue(pid); 
      unlink(pid);
    }
  
    // delete it's own msg queue
    DeleteMessageQueue();
}
